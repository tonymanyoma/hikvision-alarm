"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ElkCommand_1 = require("./ElkCommand");
var UserCode_1 = require("../../models/UserCode");
var UserCodeChangeType_1 = require("../../enums/UserCodeChangeType");
/**
 * Encodes selected area numbers.
 *
 * Two ASCII Hex characters, 0-9,A-F, using the Hex value of each
 * character as the mask for 4 areas. Right most character is
 * areas 1 to 4 with bit 0 equal to Area 1.
 *
 * @param areaNumbers An array of area numbers to encode
 * @return {string} The area numbers encoded as hex.
 */
function encodeAreaNumbers(areaNumbers) {
    if (!areaNumbers || !areaNumbers.length) {
        return '00';
    }
    // Start with an array of all 0s, replacing any area numbers with 1's.
    var bitValues = areaNumbers
        .reduce(function (bits, areaNumber) {
        return bits
            .slice(0, areaNumber - 1)
            .concat(1)
            .concat(bits.slice(areaNumber));
    }, [0, 0, 0, 0, 0, 0, 0, 0])
        .reverse(); // reverse: bit 0 = area 1, etc.
    // Join them as a single string and parse them as a binary number,
    // then convert them to a 2-character hex string.
    return parseInt(bitValues.join(''), 2)
        .toString(16)
        .padStart(2, '0')
        .toUpperCase();
}
exports.encodeAreaNumbers = encodeAreaNumbers;
function generateData(userNumber, masterOrCurrentUserCode, newUserCode, areaNumbers) {
    var authCode = typeof masterOrCurrentUserCode === 'string'
        ? new UserCode_1.default(masterOrCurrentUserCode)
        : masterOrCurrentUserCode;
    var newCode = typeof newUserCode === 'string' ? new UserCode_1.default(newUserCode) : newUserCode;
    return (userNumber.toString().padStart(3, '0') +
        authCode.encode() +
        newCode.encode() +
        encodeAreaNumbers(areaNumbers));
}
/**
 * Request Change User Code
 *
 * This command allows automation equipment to change a user code. The
 * data packet must include a Master User Code or the current user code
 * of the user code to be changed. 4.3.9 and after.
 *
 * @see 4.11.1 Request Change User Code (cu)
 */
var UserCodeChangeRequest = /** @class */ (function (_super) {
    __extends(UserCodeChangeRequest, _super);
    function UserCodeChangeRequest(userNumber, masterOrCurrentUserCode, newUserCode, areaNumbers, changeType) {
        if (changeType === void 0) { changeType = UserCodeChangeType_1.default.UserCode; }
        var _this = _super.call(this, 'c', 'u', generateData(userNumber, masterOrCurrentUserCode, newUserCode, areaNumbers)) || this;
        _this.userNumber = userNumber;
        _this.areaNumbers = areaNumbers;
        _this.changeType = changeType;
        _this.authorizationUserCode =
            typeof masterOrCurrentUserCode === 'string'
                ? new UserCode_1.default(masterOrCurrentUserCode)
                : masterOrCurrentUserCode;
        _this.newUserCode = typeof newUserCode === 'string' ? new UserCode_1.default(newUserCode) : newUserCode;
        return _this;
    }
    Object.defineProperty(UserCodeChangeRequest.prototype, "reserved", {
        get: function () {
            return this.changeType.toString() + '0';
        },
        enumerable: true,
        configurable: true
    });
    return UserCodeChangeRequest;
}(ElkCommand_1.default));
exports.default = UserCodeChangeRequest;
//# sourceMappingURL=UserCodeChangeRequest.js.map