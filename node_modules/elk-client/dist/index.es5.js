import { EventEmitter } from 'events';
import { connect } from 'tls';
import { connect as connect$1 } from 'net';
import { createSocket as createSocket$2 } from 'dgram';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var AlarmState;
(function (AlarmState) {
    AlarmState[AlarmState["None"] = 48] = "None";
    AlarmState[AlarmState["EntranceDelayActive"] = 49] = "EntranceDelayActive";
    AlarmState[AlarmState["AlarmAbortDelayActive"] = 50] = "AlarmAbortDelayActive";
    AlarmState[AlarmState["FireAlarm"] = 51] = "FireAlarm";
    AlarmState[AlarmState["MedicalAlarm"] = 52] = "MedicalAlarm";
    AlarmState[AlarmState["PoliceAlarm"] = 53] = "PoliceAlarm";
    AlarmState[AlarmState["BurglarAlarm"] = 54] = "BurglarAlarm";
    AlarmState[AlarmState["Aux1Alarm"] = 55] = "Aux1Alarm";
    AlarmState[AlarmState["Aux2Alarm"] = 56] = "Aux2Alarm";
    AlarmState[AlarmState["Aux3Alarm"] = 57] = "Aux3Alarm";
    AlarmState[AlarmState["Aux4Alarm"] = 58] = "Aux4Alarm";
    AlarmState[AlarmState["CarbonMonoxideAlarm"] = 59] = "CarbonMonoxideAlarm";
    AlarmState[AlarmState["EmergencyAlarm"] = 60] = "EmergencyAlarm";
    AlarmState[AlarmState["FreezeAlarm"] = 61] = "FreezeAlarm";
    AlarmState[AlarmState["GasAlarm"] = 62] = "GasAlarm";
    AlarmState[AlarmState["HeatAlarm"] = 63] = "HeatAlarm";
    AlarmState[AlarmState["WaterAlarm"] = 64] = "WaterAlarm";
    AlarmState[AlarmState["FireSupervisory"] = 65] = "FireSupervisory";
    AlarmState[AlarmState["VerifyFire"] = 66] = "VerifyFire"; // 'B'
})(AlarmState || (AlarmState = {}));
(function (AlarmState) {
    /**
     * Determines if an AlarmState value indicates an active alarm
     * @param alarmState The AlarmState to check
     * @returns {boolean} True if the value is an active alarm;
     *   Otherwise, false.
     */
    function isActiveAlarm(alarmState) {
        // tslint:disable-next-line:no-unnecessary-qualifier
        return alarmState > AlarmState.AlarmAbortDelayActive;
    }
    AlarmState.isActiveAlarm = isActiveAlarm;
})(AlarmState || (AlarmState = {}));
var AlarmState$1 = AlarmState;

var ArmUpState;
(function (ArmUpState) {
    ArmUpState[ArmUpState["NotReadyToArm"] = 48] = "NotReadyToArm";
    ArmUpState[ArmUpState["ReadyToArm"] = 49] = "ReadyToArm";
    ArmUpState[ArmUpState["ReadyToArmForced"] = 50] = "ReadyToArmForced";
    ArmUpState[ArmUpState["ArmedTimer"] = 51] = "ArmedTimer";
    ArmUpState[ArmUpState["ArmedFully"] = 52] = "ArmedFully";
    ArmUpState[ArmUpState["ForceArmed"] = 53] = "ForceArmed";
    ArmUpState[ArmUpState["ArmedWithBypass"] = 54] = "ArmedWithBypass"; // '6',
})(ArmUpState || (ArmUpState = {}));
var ArmUpState$1 = ArmUpState;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$1 = function(d, b) {
    extendStatics$1 = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics$1(d, b);
};

function __extends$1(d, b) {
    extendStatics$1(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

var ArmingLevel;
(function (ArmingLevel) {
    ArmingLevel[ArmingLevel["Disarm"] = 48] = "Disarm";
    ArmingLevel[ArmingLevel["ArmedAway"] = 49] = "ArmedAway";
    ArmingLevel[ArmingLevel["ArmedStay"] = 50] = "ArmedStay";
    ArmingLevel[ArmingLevel["ArmedStayInstant"] = 51] = "ArmedStayInstant";
    ArmingLevel[ArmingLevel["ArmedNight"] = 52] = "ArmedNight";
    ArmingLevel[ArmingLevel["ArmedNightInstant"] = 53] = "ArmedNightInstant";
    ArmingLevel[ArmingLevel["ArmedVacation"] = 54] = "ArmedVacation";
    ArmingLevel[ArmingLevel["ArmToNextAwayMode"] = 55] = "ArmToNextAwayMode";
    ArmingLevel[ArmingLevel["ArmToNextStayMode"] = 56] = "ArmToNextStayMode";
    ArmingLevel[ArmingLevel["ForceArmToAwayMode"] = 57] = "ForceArmToAwayMode";
    ArmingLevel[ArmingLevel["ForceArmToStayMode"] = 58] = "ForceArmToStayMode"; // ':', // Version 5.3.0 or later
})(ArmingLevel || (ArmingLevel = {}));
/* tslint:disable:no-unnecessary-qualifier */
(function (ArmingLevel) {
    ArmingLevel.AWAY_LEVELS = [
        ArmingLevel.ArmedAway,
        ArmingLevel.ArmedVacation,
        ArmingLevel.ArmToNextAwayMode,
        ArmingLevel.ForceArmToAwayMode
    ];
    ArmingLevel.NIGHT_LEVELS = [
        ArmingLevel.ArmedNight,
        ArmingLevel.ArmedNightInstant
    ];
    ArmingLevel.STAY_LEVELS = __spreadArrays(ArmingLevel.NIGHT_LEVELS, [
        ArmingLevel.ArmedStay,
        ArmingLevel.ArmedStayInstant,
        ArmingLevel.ArmToNextStayMode,
        ArmingLevel.ForceArmToStayMode
    ]);
    ArmingLevel.INSTANT_LEVELS = [
        ArmingLevel.ArmedStayInstant,
        ArmingLevel.ArmedNightInstant
    ];
    ArmingLevel.FORCE_LEVELS = [
        ArmingLevel.ForceArmToAwayMode,
        ArmingLevel.ForceArmToStayMode
    ];
    ArmingLevel.VACATION_LEVELS = [ArmingLevel.ArmedVacation];
    function isAway(armingLevel) {
        return ArmingLevel.AWAY_LEVELS.includes(armingLevel);
    }
    ArmingLevel.isAway = isAway;
    function isNight(armingLevel) {
        return ArmingLevel.NIGHT_LEVELS.includes(armingLevel);
    }
    ArmingLevel.isNight = isNight;
    function isStay(armingLevel) {
        return ArmingLevel.STAY_LEVELS.includes(armingLevel);
    }
    ArmingLevel.isStay = isStay;
    function isInstant(armingLevel) {
        return ArmingLevel.INSTANT_LEVELS.includes(armingLevel);
    }
    ArmingLevel.isInstant = isInstant;
    function isForce(armingLevel) {
        return ArmingLevel.FORCE_LEVELS.includes(armingLevel);
    }
    ArmingLevel.isForce = isForce;
    function isVacation(armingLevel) {
        return ArmingLevel.VACATION_LEVELS.includes(armingLevel);
    }
    ArmingLevel.isVacation = isVacation;
})(ArmingLevel || (ArmingLevel = {}));
var ArmingLevel$1 = ArmingLevel;

var AudioCommand;
(function (AudioCommand) {
    AudioCommand[AudioCommand["PowerOff"] = 0] = "PowerOff";
    AudioCommand[AudioCommand["PowerOn"] = 1] = "PowerOn";
    AudioCommand[AudioCommand["PowerToggle"] = 2] = "PowerToggle";
    AudioCommand[AudioCommand["NextSource"] = 3] = "NextSource";
    AudioCommand[AudioCommand["Source"] = 4] = "Source";
    AudioCommand[AudioCommand["PreviousSelect"] = 5] = "PreviousSelect";
    AudioCommand[AudioCommand["NextSelect"] = 6] = "NextSelect";
    AudioCommand[AudioCommand["VolumeDown"] = 7] = "VolumeDown";
    AudioCommand[AudioCommand["VolumeUp"] = 8] = "VolumeUp";
    AudioCommand[AudioCommand["MuteAudio"] = 9] = "MuteAudio";
    AudioCommand[AudioCommand["VolumeSet"] = 10] = "VolumeSet";
    AudioCommand[AudioCommand["Play"] = 11] = "Play";
    AudioCommand[AudioCommand["Pause"] = 12] = "Pause";
    AudioCommand[AudioCommand["Stop"] = 13] = "Stop";
    AudioCommand[AudioCommand["SelectFavorite1"] = 14] = "SelectFavorite1";
    AudioCommand[AudioCommand["SelectFavorite2"] = 15] = "SelectFavorite2";
    AudioCommand[AudioCommand["Minus"] = 16] = "Minus";
    AudioCommand[AudioCommand["Plus"] = 17] = "Plus";
    AudioCommand[AudioCommand["AllZonesOff"] = 18] = "AllZonesOff";
    AudioCommand[AudioCommand["AllZonesOn"] = 19] = "AllZonesOn";
    AudioCommand[AudioCommand["AudioSystemManufacturer"] = 20] = "AudioSystemManufacturer";
})(AudioCommand || (AudioCommand = {}));

var BeepAndChimeMode;
(function (BeepAndChimeMode) {
    BeepAndChimeMode[BeepAndChimeMode["Off"] = 48] = "Off";
    BeepAndChimeMode[BeepAndChimeMode["Single"] = 49] = "Single";
    BeepAndChimeMode[BeepAndChimeMode["Constant"] = 50] = "Constant";
    BeepAndChimeMode[BeepAndChimeMode["Chime"] = 52] = "Chime"; // '4'
})(BeepAndChimeMode || (BeepAndChimeMode = {}));

var ChimeMode;
(function (ChimeMode) {
    ChimeMode[ChimeMode["Off"] = 48] = "Off";
    ChimeMode[ChimeMode["Chime"] = 49] = "Chime";
    ChimeMode[ChimeMode["Voice"] = 50] = "Voice";
    ChimeMode[ChimeMode["ChimeAndVoice"] = 51] = "ChimeAndVoice"; // '3'
})(ChimeMode || (ChimeMode = {}));

var CustomValueFormat;
(function (CustomValueFormat) {
    CustomValueFormat[CustomValueFormat["Number"] = 0] = "Number";
    CustomValueFormat[CustomValueFormat["Timer"] = 1] = "Timer";
    CustomValueFormat[CustomValueFormat["TimeOfDay"] = 2] = "TimeOfDay";
})(CustomValueFormat || (CustomValueFormat = {}));
var CustomValueFormat$1 = CustomValueFormat;

var DayOfWeek;
(function (DayOfWeek) {
    DayOfWeek[DayOfWeek["Sunday"] = 1] = "Sunday";
    DayOfWeek[DayOfWeek["Monday"] = 2] = "Monday";
    DayOfWeek[DayOfWeek["Tuesday"] = 3] = "Tuesday";
    DayOfWeek[DayOfWeek["Wednesday"] = 4] = "Wednesday";
    DayOfWeek[DayOfWeek["Thursday"] = 5] = "Thursday";
    DayOfWeek[DayOfWeek["Friday"] = 6] = "Friday";
    DayOfWeek[DayOfWeek["Saturday"] = 7] = "Saturday";
})(DayOfWeek || (DayOfWeek = {}));
(function (DayOfWeek) {
    function isWeekend(dayOfWeek) {
        // tslint:disable-next-line:no-unnecessary-qualifier
        return dayOfWeek === DayOfWeek.Saturday || dayOfWeek === DayOfWeek.Sunday;
    }
    DayOfWeek.isWeekend = isWeekend;
    function isWeekday(dayOfWeek) {
        return !isWeekend(dayOfWeek);
    }
    DayOfWeek.isWeekday = isWeekday;
})(DayOfWeek || (DayOfWeek = {}));

var DisplayTextClearOption;
(function (DisplayTextClearOption) {
    DisplayTextClearOption[DisplayTextClearOption["Clear"] = 0] = "Clear";
    DisplayTextClearOption[DisplayTextClearOption["ClearWithStarKey"] = 1] = "ClearWithStarKey";
    DisplayTextClearOption[DisplayTextClearOption["DisplayUntilTimeout"] = 2] = "DisplayUntilTimeout";
})(DisplayTextClearOption || (DisplayTextClearOption = {}));
var DisplayTextClearOption$1 = DisplayTextClearOption;

var EventType;
(function (EventType) {
    EventType[EventType["NoEvent"] = 1000] = "NoEvent";
    EventType[EventType["FireALarm"] = 1001] = "FireALarm";
    EventType[EventType["FireSupervisoryAlarm"] = 1002] = "FireSupervisoryAlarm";
    EventType[EventType["BurglarAlarmAnyArea"] = 1003] = "BurglarAlarmAnyArea";
    EventType[EventType["MedicalAlarmAnyArea"] = 1004] = "MedicalAlarmAnyArea";
    EventType[EventType["PoliceAlarmAnyArea"] = 1005] = "PoliceAlarmAnyArea";
    EventType[EventType["Aux1_24HourAlarmAnyArea"] = 1006] = "Aux1_24HourAlarmAnyArea";
    EventType[EventType["Aux2_24HourAlarmAnyArea"] = 1007] = "Aux2_24HourAlarmAnyArea";
    EventType[EventType["CarbonMonoxideAlarmAnyArea"] = 1008] = "CarbonMonoxideAlarmAnyArea";
    EventType[EventType["EmergencyAlarmAnyArea"] = 1009] = "EmergencyAlarmAnyArea";
    EventType[EventType["FreezeAlarmAnyArea"] = 1010] = "FreezeAlarmAnyArea";
    EventType[EventType["GasAlarmAnyArea"] = 1011] = "GasAlarmAnyArea";
    EventType[EventType["HeatAlarmAnyArea"] = 1012] = "HeatAlarmAnyArea";
    EventType[EventType["WaterAlarmAnyArea"] = 1013] = "WaterAlarmAnyArea";
    EventType[EventType["AlarmAnyArea"] = 1014] = "AlarmAnyArea";
    EventType[EventType["BurglarAlarmArea1"] = 1015] = "BurglarAlarmArea1";
    EventType[EventType["BurglarAlarmArea2"] = 1016] = "BurglarAlarmArea2";
    EventType[EventType["BurglarAlarmArea3"] = 1017] = "BurglarAlarmArea3";
    EventType[EventType["BurglarAlarmArea4"] = 1018] = "BurglarAlarmArea4";
    EventType[EventType["BurglarAlarmArea5"] = 1019] = "BurglarAlarmArea5";
    EventType[EventType["BurglarAlarmArea6"] = 1020] = "BurglarAlarmArea6";
    EventType[EventType["BurglarAlarmArea7"] = 1021] = "BurglarAlarmArea7";
    EventType[EventType["BurglarAlarmArea8"] = 1022] = "BurglarAlarmArea8";
    EventType[EventType["MedicalAlarmArea1"] = 1023] = "MedicalAlarmArea1";
    EventType[EventType["MedicalAlarmArea2"] = 1024] = "MedicalAlarmArea2";
    EventType[EventType["MedicalAlarmArea3"] = 1025] = "MedicalAlarmArea3";
    EventType[EventType["MedicalAlarmArea4"] = 1026] = "MedicalAlarmArea4";
    EventType[EventType["MedicalAlarmArea5"] = 1027] = "MedicalAlarmArea5";
    EventType[EventType["MedicalAlarmArea6"] = 1028] = "MedicalAlarmArea6";
    EventType[EventType["MedicalAlarmArea7"] = 1029] = "MedicalAlarmArea7";
    EventType[EventType["MedicalAlarmArea8"] = 1030] = "MedicalAlarmArea8";
    EventType[EventType["PoliceAlarmArea1"] = 1031] = "PoliceAlarmArea1";
    EventType[EventType["PoliceAlarmArea2"] = 1032] = "PoliceAlarmArea2";
    EventType[EventType["PoliceAlarmArea3"] = 1033] = "PoliceAlarmArea3";
    EventType[EventType["PoliceAlarmArea4"] = 1034] = "PoliceAlarmArea4";
    EventType[EventType["PoliceAlarmArea5"] = 1035] = "PoliceAlarmArea5";
    EventType[EventType["PoliceAlarmArea6"] = 1036] = "PoliceAlarmArea6";
    EventType[EventType["PoliceAlarmArea7"] = 1037] = "PoliceAlarmArea7";
    EventType[EventType["PoliceAlarmArea8"] = 1038] = "PoliceAlarmArea8";
    EventType[EventType["Aux1_24HourAlarmArea1"] = 1039] = "Aux1_24HourAlarmArea1";
    EventType[EventType["Aux1_24HourAlarmArea2"] = 1040] = "Aux1_24HourAlarmArea2";
    EventType[EventType["Aux1_24HourAlarmArea3"] = 1041] = "Aux1_24HourAlarmArea3";
    EventType[EventType["Aux1_24HourAlarmArea4"] = 1042] = "Aux1_24HourAlarmArea4";
    EventType[EventType["Aux1_24HourAlarmArea5"] = 1043] = "Aux1_24HourAlarmArea5";
    EventType[EventType["Aux1_24HourAlarmArea6"] = 1044] = "Aux1_24HourAlarmArea6";
    EventType[EventType["Aux1_24HourAlarmArea7"] = 1045] = "Aux1_24HourAlarmArea7";
    EventType[EventType["Aux1_24HourAlarmArea8"] = 1046] = "Aux1_24HourAlarmArea8";
    EventType[EventType["Aux2_24HourAlarmArea1"] = 1047] = "Aux2_24HourAlarmArea1";
    EventType[EventType["Aux2_24HourAlarmArea2"] = 1048] = "Aux2_24HourAlarmArea2";
    EventType[EventType["Aux2_24HourAlarmArea3"] = 1049] = "Aux2_24HourAlarmArea3";
    EventType[EventType["Aux2_24HourAlarmArea4"] = 1050] = "Aux2_24HourAlarmArea4";
    EventType[EventType["Aux2_24HourAlarmArea5"] = 1051] = "Aux2_24HourAlarmArea5";
    EventType[EventType["Aux2_24HourAlarmArea6"] = 1052] = "Aux2_24HourAlarmArea6";
    EventType[EventType["Aux2_24HourAlarmArea7"] = 1053] = "Aux2_24HourAlarmArea7";
    EventType[EventType["Aux2_24HourAlarmArea8"] = 1054] = "Aux2_24HourAlarmArea8";
    EventType[EventType["CarbonMonoxideAlarmArea1"] = 1055] = "CarbonMonoxideAlarmArea1";
    EventType[EventType["CarbonMonoxideAlarmArea2"] = 1056] = "CarbonMonoxideAlarmArea2";
    EventType[EventType["CarbonMonoxideAlarmArea3"] = 1057] = "CarbonMonoxideAlarmArea3";
    EventType[EventType["CarbonMonoxideAlarmArea4"] = 1058] = "CarbonMonoxideAlarmArea4";
    EventType[EventType["CarbonMonoxideAlarmArea5"] = 1059] = "CarbonMonoxideAlarmArea5";
    EventType[EventType["CarbonMonoxideAlarmArea6"] = 1060] = "CarbonMonoxideAlarmArea6";
    EventType[EventType["CarbonMonoxideAlarmArea7"] = 1061] = "CarbonMonoxideAlarmArea7";
    EventType[EventType["CarbonMonoxideAlarmArea8"] = 1062] = "CarbonMonoxideAlarmArea8";
    EventType[EventType["EmergencyAlarmArea1"] = 1063] = "EmergencyAlarmArea1";
    EventType[EventType["EmergencyAlarmArea2"] = 1064] = "EmergencyAlarmArea2";
    EventType[EventType["EmergencyAlarmArea3"] = 1065] = "EmergencyAlarmArea3";
    EventType[EventType["EmergencyAlarmArea4"] = 1066] = "EmergencyAlarmArea4";
    EventType[EventType["EmergencyAlarmArea5"] = 1067] = "EmergencyAlarmArea5";
    EventType[EventType["EmergencyAlarmArea6"] = 1068] = "EmergencyAlarmArea6";
    EventType[EventType["EmergencyAlarmArea7"] = 1069] = "EmergencyAlarmArea7";
    EventType[EventType["EmergencyAlarmArea8"] = 1070] = "EmergencyAlarmArea8";
    EventType[EventType["FreezeAlarmArea1"] = 1071] = "FreezeAlarmArea1";
    EventType[EventType["FreezeAlarmArea2"] = 1072] = "FreezeAlarmArea2";
    EventType[EventType["FreezeAlarmArea3"] = 1073] = "FreezeAlarmArea3";
    EventType[EventType["FreezeAlarmArea4"] = 1074] = "FreezeAlarmArea4";
    EventType[EventType["FreezeAlarmArea5"] = 1075] = "FreezeAlarmArea5";
    EventType[EventType["FreezeAlarmArea6"] = 1076] = "FreezeAlarmArea6";
    EventType[EventType["FreezeAlarmArea7"] = 1077] = "FreezeAlarmArea7";
    EventType[EventType["FreezeAlarmArea8"] = 1078] = "FreezeAlarmArea8";
    EventType[EventType["GasAlarmArea1"] = 1079] = "GasAlarmArea1";
    EventType[EventType["GasAlarmArea2"] = 1080] = "GasAlarmArea2";
    EventType[EventType["GasAlarmArea3"] = 1081] = "GasAlarmArea3";
    EventType[EventType["GasAlarmArea4"] = 1082] = "GasAlarmArea4";
    EventType[EventType["GasAlarmArea5"] = 1083] = "GasAlarmArea5";
    EventType[EventType["GasAlarmArea6"] = 1084] = "GasAlarmArea6";
    EventType[EventType["GasAlarmArea7"] = 1085] = "GasAlarmArea7";
    EventType[EventType["GasAlarmArea8"] = 1086] = "GasAlarmArea8";
    EventType[EventType["HeatAlarmArea1"] = 1087] = "HeatAlarmArea1";
    EventType[EventType["HeatAlarmArea2"] = 1088] = "HeatAlarmArea2";
    EventType[EventType["HeatAlarmArea3"] = 1089] = "HeatAlarmArea3";
    EventType[EventType["HeatAlarmArea4"] = 1090] = "HeatAlarmArea4";
    EventType[EventType["HeatAlarmArea5"] = 1091] = "HeatAlarmArea5";
    EventType[EventType["HeatAlarmArea6"] = 1092] = "HeatAlarmArea6";
    EventType[EventType["HeatAlarmArea7"] = 1093] = "HeatAlarmArea7";
    EventType[EventType["HeatAlarmArea8"] = 1094] = "HeatAlarmArea8";
    EventType[EventType["WaterAlarmArea1"] = 1095] = "WaterAlarmArea1";
    EventType[EventType["WaterAlarmArea2"] = 1096] = "WaterAlarmArea2";
    EventType[EventType["WaterAlarmArea3"] = 1097] = "WaterAlarmArea3";
    EventType[EventType["WaterAlarmArea4"] = 1098] = "WaterAlarmArea4";
    EventType[EventType["WaterAlarmArea5"] = 1099] = "WaterAlarmArea5";
    EventType[EventType["WaterAlarmArea6"] = 1100] = "WaterAlarmArea6";
    EventType[EventType["WaterAlarmArea7"] = 1101] = "WaterAlarmArea7";
    EventType[EventType["WaterAlarmArea8"] = 1102] = "WaterAlarmArea8";
    EventType[EventType["AlarmArea1"] = 1103] = "AlarmArea1";
    EventType[EventType["AlarmArea2"] = 1104] = "AlarmArea2";
    EventType[EventType["AlarmArea3"] = 1105] = "AlarmArea3";
    EventType[EventType["AlarmArea4"] = 1106] = "AlarmArea4";
    EventType[EventType["AlarmArea5"] = 1107] = "AlarmArea5";
    EventType[EventType["AlarmArea6"] = 1108] = "AlarmArea6";
    EventType[EventType["AlarmArea7"] = 1109] = "AlarmArea7";
    EventType[EventType["AlarmArea8"] = 1110] = "AlarmArea8";
    EventType[EventType["CodeLockout"] = 1111] = "CodeLockout";
    EventType[EventType["CodeLockoutKeypad1"] = 1112] = "CodeLockoutKeypad1";
    EventType[EventType["CodeLockoutKeypad2"] = 1113] = "CodeLockoutKeypad2";
    EventType[EventType["CodeLockoutKeypad3"] = 1114] = "CodeLockoutKeypad3";
    EventType[EventType["CodeLockoutKeypad4"] = 1115] = "CodeLockoutKeypad4";
    EventType[EventType["CodeLockoutKeypad5"] = 1116] = "CodeLockoutKeypad5";
    EventType[EventType["CodeLockoutKeypad6"] = 1117] = "CodeLockoutKeypad6";
    EventType[EventType["CodeLockoutKeypad7"] = 1118] = "CodeLockoutKeypad7";
    EventType[EventType["CodeLockoutKeypad8"] = 1119] = "CodeLockoutKeypad8";
    EventType[EventType["CodeLockoutKeypad9"] = 1120] = "CodeLockoutKeypad9";
    EventType[EventType["CodeLockoutKeypad10"] = 1121] = "CodeLockoutKeypad10";
    EventType[EventType["CodeLockoutKeypad11"] = 1122] = "CodeLockoutKeypad11";
    EventType[EventType["CodeLockoutKeypad12"] = 1123] = "CodeLockoutKeypad12";
    EventType[EventType["CodeLockoutKeypad13"] = 1124] = "CodeLockoutKeypad13";
    EventType[EventType["CodeLockoutKeypad14"] = 1125] = "CodeLockoutKeypad14";
    EventType[EventType["CodeLockoutKeypad15"] = 1126] = "CodeLockoutKeypad15";
    EventType[EventType["CodeLockoutKeypad16"] = 1127] = "CodeLockoutKeypad16";
    EventType[EventType["FireTrouble"] = 1128] = "FireTrouble";
    EventType[EventType["BurglarTrouble"] = 1129] = "BurglarTrouble";
    EventType[EventType["FailToCommunicateTrouble"] = 1130] = "FailToCommunicateTrouble";
    EventType[EventType["RfSensorLowBatteryTrouble"] = 1131] = "RfSensorLowBatteryTrouble";
    EventType[EventType["LostAncModuleTrouble"] = 1132] = "LostAncModuleTrouble";
    EventType[EventType["LostKeypadTrouble"] = 1133] = "LostKeypadTrouble";
    EventType[EventType["LostInputExpanderTrouble"] = 1134] = "LostInputExpanderTrouble";
    EventType[EventType["LostOutputExpanderTrouble"] = 1135] = "LostOutputExpanderTrouble";
})(EventType || (EventType = {}));

var FunctionKey;
(function (FunctionKey) {
    FunctionKey[FunctionKey["None"] = 48] = "None";
    FunctionKey[FunctionKey["F1"] = 49] = "F1";
    FunctionKey[FunctionKey["F2"] = 50] = "F2";
    FunctionKey[FunctionKey["F3"] = 51] = "F3";
    FunctionKey[FunctionKey["F4"] = 52] = "F4";
    FunctionKey[FunctionKey["F5"] = 53] = "F5";
    FunctionKey[FunctionKey["F6"] = 54] = "F6";
    FunctionKey[FunctionKey["SilenceTroubleBeep"] = 42] = "SilenceTroubleBeep";
    FunctionKey[FunctionKey["Chime"] = 67] = "Chime"; // 'C' (0x43)
})(FunctionKey || (FunctionKey = {}));
var FunctionKey$1 = FunctionKey;

var IlluminationStatus;
(function (IlluminationStatus) {
    IlluminationStatus[IlluminationStatus["Off"] = 48] = "Off";
    IlluminationStatus[IlluminationStatus["On"] = 49] = "On";
    IlluminationStatus[IlluminationStatus["Blinking"] = 50] = "Blinking"; // '2',
})(IlluminationStatus || (IlluminationStatus = {}));

var KeypadKey;
(function (KeypadKey) {
    KeypadKey[KeypadKey["None"] = 0] = "None";
    KeypadKey[KeypadKey["Star"] = 11] = "Star";
    KeypadKey[KeypadKey["Pound"] = 12] = "Pound";
    KeypadKey[KeypadKey["F1"] = 13] = "F1";
    KeypadKey[KeypadKey["F2"] = 14] = "F2";
    KeypadKey[KeypadKey["F3"] = 15] = "F3";
    KeypadKey[KeypadKey["F4"] = 16] = "F4";
    KeypadKey[KeypadKey["Stay"] = 17] = "Stay";
    KeypadKey[KeypadKey["Exit"] = 18] = "Exit";
    KeypadKey[KeypadKey["Chime"] = 19] = "Chime";
    KeypadKey[KeypadKey["Bypass"] = 20] = "Bypass";
    KeypadKey[KeypadKey["Elk"] = 21] = "Elk";
    KeypadKey[KeypadKey["Down"] = 22] = "Down";
    KeypadKey[KeypadKey["Up"] = 23] = "Up";
    KeypadKey[KeypadKey["Right"] = 24] = "Right";
    KeypadKey[KeypadKey["Left"] = 25] = "Left";
    KeypadKey[KeypadKey["F6"] = 26] = "F6";
    KeypadKey[KeypadKey["F7"] = 27] = "F7";
    KeypadKey[KeypadKey["Data"] = 28] = "Data"; // Data was entered, this acts as a carriage return
})(KeypadKey || (KeypadKey = {}));

var LogWriteType;
(function (LogWriteType) {
    LogWriteType[LogWriteType["AlarmRestore"] = 64] = "AlarmRestore";
    LogWriteType[LogWriteType["Alarm"] = 128] = "Alarm";
})(LogWriteType || (LogWriteType = {}));

var MonthOfYear;
(function (MonthOfYear) {
    MonthOfYear[MonthOfYear["January"] = 1] = "January";
    MonthOfYear[MonthOfYear["February"] = 2] = "February";
    MonthOfYear[MonthOfYear["March"] = 3] = "March";
    MonthOfYear[MonthOfYear["April"] = 4] = "April";
    MonthOfYear[MonthOfYear["May"] = 5] = "May";
    MonthOfYear[MonthOfYear["June"] = 6] = "June";
    MonthOfYear[MonthOfYear["July"] = 7] = "July";
    MonthOfYear[MonthOfYear["August"] = 8] = "August";
    MonthOfYear[MonthOfYear["September"] = 9] = "September";
    MonthOfYear[MonthOfYear["October"] = 10] = "October";
    MonthOfYear[MonthOfYear["November"] = 11] = "November";
    MonthOfYear[MonthOfYear["December"] = 12] = "December";
})(MonthOfYear || (MonthOfYear = {}));

var PartyMode;
(function (PartyMode) {
    PartyMode[PartyMode["Off"] = 0] = "Off";
    PartyMode[PartyMode["On"] = 1] = "On";
    PartyMode[PartyMode["Master"] = 2] = "Master";
})(PartyMode || (PartyMode = {}));

var PlcFunctionCode;
(function (PlcFunctionCode) {
    PlcFunctionCode[PlcFunctionCode["AllUnitsOff"] = 1] = "AllUnitsOff";
    PlcFunctionCode[PlcFunctionCode["AllLightsOn"] = 2] = "AllLightsOn";
    PlcFunctionCode[PlcFunctionCode["UnitOn"] = 3] = "UnitOn";
    PlcFunctionCode[PlcFunctionCode["UnitOff"] = 4] = "UnitOff";
    PlcFunctionCode[PlcFunctionCode["Dim"] = 5] = "Dim";
    PlcFunctionCode[PlcFunctionCode["Bright"] = 6] = "Bright";
    PlcFunctionCode[PlcFunctionCode["AllLightsOff"] = 7] = "AllLightsOff";
    PlcFunctionCode[PlcFunctionCode["ExtendedCode"] = 8] = "ExtendedCode";
    PlcFunctionCode[PlcFunctionCode["PresetDim"] = 9] = "PresetDim";
    PlcFunctionCode[PlcFunctionCode["ExtendedData"] = 10] = "ExtendedData";
    PlcFunctionCode[PlcFunctionCode["StatusRequest"] = 11] = "StatusRequest";
    PlcFunctionCode[PlcFunctionCode["HailRequest"] = 12] = "HailRequest";
    PlcFunctionCode[PlcFunctionCode["HailAcknowledgement"] = 13] = "HailAcknowledgement";
    PlcFunctionCode[PlcFunctionCode["StatusOn"] = 14] = "StatusOn";
    PlcFunctionCode[PlcFunctionCode["StatusOff"] = 15] = "StatusOff";
})(PlcFunctionCode || (PlcFunctionCode = {}));

var SystemTroubleType;
(function (SystemTroubleType) {
    SystemTroubleType[SystemTroubleType["None"] = 0] = "None";
    SystemTroubleType[SystemTroubleType["ACFail"] = 1] = "ACFail";
    SystemTroubleType[SystemTroubleType["BoxTamper"] = 2] = "BoxTamper";
    SystemTroubleType[SystemTroubleType["FailToCommunicate"] = 4] = "FailToCommunicate";
    SystemTroubleType[SystemTroubleType["EEPromMemoryError"] = 8] = "EEPromMemoryError";
    SystemTroubleType[SystemTroubleType["LowBatteryControl"] = 16] = "LowBatteryControl";
    SystemTroubleType[SystemTroubleType["TransmitterLowBattery"] = 32] = "TransmitterLowBattery";
    SystemTroubleType[SystemTroubleType["OverCurrent"] = 64] = "OverCurrent";
    SystemTroubleType[SystemTroubleType["TelephoneFault"] = 128] = "TelephoneFault";
    SystemTroubleType[SystemTroubleType["Output2"] = 256] = "Output2";
    SystemTroubleType[SystemTroubleType["MissingKeypad"] = 512] = "MissingKeypad";
    SystemTroubleType[SystemTroubleType["ZoneExpander"] = 1024] = "ZoneExpander";
    SystemTroubleType[SystemTroubleType["OutputExpander"] = 2048] = "OutputExpander";
    SystemTroubleType[SystemTroubleType["ELKRPRemoteAccess"] = 4096] = "ELKRPRemoteAccess";
    SystemTroubleType[SystemTroubleType["CommonAreaNotArmed"] = 8192] = "CommonAreaNotArmed";
    SystemTroubleType[SystemTroubleType["FlashMemoryError"] = 16384] = "FlashMemoryError";
    SystemTroubleType[SystemTroubleType["SecurityAlert"] = 32768] = "SecurityAlert";
    SystemTroubleType[SystemTroubleType["SerialPortExpander"] = 65536] = "SerialPortExpander";
    SystemTroubleType[SystemTroubleType["LostTransmitter"] = 131072] = "LostTransmitter";
    SystemTroubleType[SystemTroubleType["GESmokeCleanMe"] = 262144] = "GESmokeCleanMe";
    SystemTroubleType[SystemTroubleType["EthernetTrouble"] = 524288] = "EthernetTrouble";
    SystemTroubleType[SystemTroubleType["DisplayMessageInKeypadLine1"] = 1048576] = "DisplayMessageInKeypadLine1";
    SystemTroubleType[SystemTroubleType["DisplayMessageInKeypadLine2"] = 2097152] = "DisplayMessageInKeypadLine2";
    SystemTroubleType[SystemTroubleType["FireTrouble"] = 4194304] = "FireTrouble";
})(SystemTroubleType || (SystemTroubleType = {}));
var SystemTroubleType$1 = SystemTroubleType;

var TemperatureDeviceType;
(function (TemperatureDeviceType) {
    TemperatureDeviceType[TemperatureDeviceType["TemperatureProbe"] = 0] = "TemperatureProbe";
    TemperatureDeviceType[TemperatureDeviceType["Keypad"] = 1] = "Keypad";
    TemperatureDeviceType[TemperatureDeviceType["Thermostat"] = 2] = "Thermostat";
})(TemperatureDeviceType || (TemperatureDeviceType = {}));
var TemperatureDeviceType$1 = TemperatureDeviceType;

var TextDescriptionType;
(function (TextDescriptionType) {
    TextDescriptionType[TextDescriptionType["ZoneName"] = 0] = "ZoneName";
    TextDescriptionType[TextDescriptionType["AreaName"] = 1] = "AreaName";
    TextDescriptionType[TextDescriptionType["UserName"] = 2] = "UserName";
    TextDescriptionType[TextDescriptionType["KeypadName"] = 3] = "KeypadName";
    TextDescriptionType[TextDescriptionType["OutputName"] = 4] = "OutputName";
    TextDescriptionType[TextDescriptionType["TaskName"] = 5] = "TaskName";
    TextDescriptionType[TextDescriptionType["TelephoneName"] = 6] = "TelephoneName";
    TextDescriptionType[TextDescriptionType["LightName"] = 7] = "LightName";
    TextDescriptionType[TextDescriptionType["AlarmDurationName"] = 8] = "AlarmDurationName";
    TextDescriptionType[TextDescriptionType["CustomSettings"] = 9] = "CustomSettings";
    TextDescriptionType[TextDescriptionType["CounterName"] = 10] = "CounterName";
    TextDescriptionType[TextDescriptionType["ThermostatName"] = 11] = "ThermostatName";
    TextDescriptionType[TextDescriptionType["FunctionKey1Name"] = 12] = "FunctionKey1Name";
    TextDescriptionType[TextDescriptionType["FunctionKey2Name"] = 13] = "FunctionKey2Name";
    TextDescriptionType[TextDescriptionType["FunctionKey3Name"] = 14] = "FunctionKey3Name";
    TextDescriptionType[TextDescriptionType["FunctionKey4Name"] = 15] = "FunctionKey4Name";
    TextDescriptionType[TextDescriptionType["FunctionKey5Name"] = 16] = "FunctionKey5Name";
    TextDescriptionType[TextDescriptionType["FunctionKey6Name"] = 17] = "FunctionKey6Name";
    TextDescriptionType[TextDescriptionType["AudioZoneName"] = 18] = "AudioZoneName";
    TextDescriptionType[TextDescriptionType["AudioSourceName"] = 19] = "AudioSourceName";
})(TextDescriptionType || (TextDescriptionType = {}));

var ThermostatMode;
(function (ThermostatMode) {
    ThermostatMode[ThermostatMode["Off"] = 48] = "Off";
    ThermostatMode[ThermostatMode["Heat"] = 49] = "Heat";
    ThermostatMode[ThermostatMode["Cool"] = 50] = "Cool";
    ThermostatMode[ThermostatMode["Auto"] = 51] = "Auto";
    ThermostatMode[ThermostatMode["EmergencyHeat"] = 52] = "EmergencyHeat"; // '4'
})(ThermostatMode || (ThermostatMode = {}));

var ThermostatSetType;
(function (ThermostatSetType) {
    ThermostatSetType[ThermostatSetType["Mode"] = 0] = "Mode";
    ThermostatSetType[ThermostatSetType["Hold"] = 1] = "Hold";
    ThermostatSetType[ThermostatSetType["Fan"] = 2] = "Fan";
    ThermostatSetType[ThermostatSetType["Temperature"] = 3] = "Temperature";
    ThermostatSetType[ThermostatSetType["CoolSetPoint"] = 4] = "CoolSetPoint";
    ThermostatSetType[ThermostatSetType["HeatSetPoint"] = 5] = "HeatSetPoint";
})(ThermostatSetType || (ThermostatSetType = {}));
var ThermostatSetType$1 = ThermostatSetType;

var UserCodeChangeType;
(function (UserCodeChangeType) {
    UserCodeChangeType[UserCodeChangeType["UserCode"] = 0] = "UserCode";
    UserCodeChangeType[UserCodeChangeType["SetRestriction"] = 1] = "SetRestriction";
    UserCodeChangeType[UserCodeChangeType["ClearRestriction"] = 2] = "ClearRestriction";
})(UserCodeChangeType || (UserCodeChangeType = {}));
var UserCodeChangeType$1 = UserCodeChangeType;

var UserCodeType;
(function (UserCodeType) {
    UserCodeType[UserCodeType["User"] = 49] = "User";
    UserCodeType[UserCodeType["Master"] = 50] = "Master";
    UserCodeType[UserCodeType["Installer"] = 51] = "Installer";
    UserCodeType[UserCodeType["ElkRP"] = 52] = "ElkRP";
})(UserCodeType || (UserCodeType = {}));

var ZoneDefinition;
(function (ZoneDefinition) {
    ZoneDefinition[ZoneDefinition["Disabled"] = 48] = "Disabled";
    ZoneDefinition[ZoneDefinition["BurglarEntryExit1"] = 49] = "BurglarEntryExit1";
    ZoneDefinition[ZoneDefinition["BurglarEntryExit2"] = 50] = "BurglarEntryExit2";
    ZoneDefinition[ZoneDefinition["BurglarPerimeterInstant"] = 51] = "BurglarPerimeterInstant";
    ZoneDefinition[ZoneDefinition["BurglarInterior"] = 52] = "BurglarInterior";
    ZoneDefinition[ZoneDefinition["BurglarInteriorFollower"] = 53] = "BurglarInteriorFollower";
    ZoneDefinition[ZoneDefinition["BurglarInteriorNight"] = 54] = "BurglarInteriorNight";
    ZoneDefinition[ZoneDefinition["BurglarInteriorNightDelay"] = 55] = "BurglarInteriorNightDelay";
    ZoneDefinition[ZoneDefinition["Burglar24Hour"] = 56] = "Burglar24Hour";
    ZoneDefinition[ZoneDefinition["BurglarBoxTamper"] = 57] = "BurglarBoxTamper";
    ZoneDefinition[ZoneDefinition["FireAlarm"] = 58] = "FireAlarm";
    ZoneDefinition[ZoneDefinition["FireVerified"] = 59] = "FireVerified";
    ZoneDefinition[ZoneDefinition["FireSupervisory"] = 60] = "FireSupervisory";
    ZoneDefinition[ZoneDefinition["AuxAlarm1"] = 61] = "AuxAlarm1";
    ZoneDefinition[ZoneDefinition["AuxAlarm2"] = 62] = "AuxAlarm2";
    ZoneDefinition[ZoneDefinition["Keyfob"] = 63] = "Keyfob";
    ZoneDefinition[ZoneDefinition["NonAlarm"] = 64] = "NonAlarm";
    ZoneDefinition[ZoneDefinition["CarbonMonoxide"] = 65] = "CarbonMonoxide";
    ZoneDefinition[ZoneDefinition["EmergencyAlarm"] = 66] = "EmergencyAlarm";
    ZoneDefinition[ZoneDefinition["FreezeAlarm"] = 67] = "FreezeAlarm";
    ZoneDefinition[ZoneDefinition["GasAlarm"] = 68] = "GasAlarm";
    ZoneDefinition[ZoneDefinition["HeatAlarm"] = 69] = "HeatAlarm";
    ZoneDefinition[ZoneDefinition["MedicalAlarm"] = 70] = "MedicalAlarm";
    ZoneDefinition[ZoneDefinition["PoliceAlarm"] = 71] = "PoliceAlarm";
    ZoneDefinition[ZoneDefinition["PoliceNoIndication"] = 72] = "PoliceNoIndication";
    ZoneDefinition[ZoneDefinition["WaterAlarm"] = 73] = "WaterAlarm";
    ZoneDefinition[ZoneDefinition["KeyMomentaryArmDisarm"] = 74] = "KeyMomentaryArmDisarm";
    ZoneDefinition[ZoneDefinition["KeyMomentaryArmAway"] = 75] = "KeyMomentaryArmAway";
    ZoneDefinition[ZoneDefinition["KeyMomentaryArmStay"] = 76] = "KeyMomentaryArmStay";
    ZoneDefinition[ZoneDefinition["KeyMomentaryDisarm"] = 77] = "KeyMomentaryDisarm";
    ZoneDefinition[ZoneDefinition["KeyOnOff"] = 78] = "KeyOnOff";
    ZoneDefinition[ZoneDefinition["MuteAudibles"] = 79] = "MuteAudibles";
    ZoneDefinition[ZoneDefinition["PowerSupervisory"] = 80] = "PowerSupervisory";
    ZoneDefinition[ZoneDefinition["Temperature"] = 81] = "Temperature";
    ZoneDefinition[ZoneDefinition["AnalogZone"] = 82] = "AnalogZone";
    ZoneDefinition[ZoneDefinition["PhoneKey"] = 83] = "PhoneKey";
    ZoneDefinition[ZoneDefinition["IntercomKey"] = 84] = "IntercomKey"; // 'T'
})(ZoneDefinition || (ZoneDefinition = {}));
var ZoneDefinition$1 = ZoneDefinition;

var ZoneLogicalState;
(function (ZoneLogicalState) {
    ZoneLogicalState[ZoneLogicalState["Normal"] = 0] = "Normal";
    ZoneLogicalState[ZoneLogicalState["Trouble"] = 1] = "Trouble";
    ZoneLogicalState[ZoneLogicalState["Violated"] = 2] = "Violated";
    ZoneLogicalState[ZoneLogicalState["Bypassed"] = 3] = "Bypassed";
})(ZoneLogicalState || (ZoneLogicalState = {}));

var ZonePhysicalState;
(function (ZonePhysicalState) {
    ZonePhysicalState[ZonePhysicalState["Unconfigured"] = 0] = "Unconfigured";
    ZonePhysicalState[ZonePhysicalState["Open"] = 1] = "Open";
    ZonePhysicalState[ZonePhysicalState["EOL"] = 2] = "EOL";
    ZonePhysicalState[ZonePhysicalState["Short"] = 3] = "Short";
})(ZonePhysicalState || (ZonePhysicalState = {}));

/**
 * The number of characters used to represent the checksum in a
 * message packet.
 * @see 4.1.6
 */
var CHECKSUM_WIDTH = 2;
/**
 * The number of characters used to represent the packet length in
 * a message packet.
 * @see 4.1.1
 */
var PACKET_LENGTH_WIDTH = 2;
/**
 * The default reserved characters for a message packet.
 * @see 4.1.5
 */
var RESERVED_DEFAULT = '00';
/**
 * The number of characters used to represent the reserved portion of
 * a message packet.
 * @see 4.1.5
 */
var RESERVED_WIDTH = RESERVED_DEFAULT.length;
/**
 * The message termination characters
 * @see 4.1.7
 */
var TERMINATOR = '\r\n';

/**
 * Converts a number to it's hexadecimal notation equivalent.
 * @param value The number to convert.
 * @param width The number of characters to pad the result to.
 * @return {string} A hexidecimal string representing the number provided.
 */
function numberToHex(value, width) {
    if (width === void 0) { width = 2; }
    return value
        .toString(16)
        .toUpperCase()
        .padStart(width, '0');
}

/**
 * Returns the two's complement of a value between 0 and 255.
 * @param value The value to calculate the two's compliment for.
 * @return The two's complement of the value.
 * @throws {RAngeError} if the value is less than 0 or greater than 255.
 */
function twosComplement(value) {
    if (value < 0 || value > 255) {
        throw new RangeError('Value must be between 0 and 255');
    }
    return (value ^ 0xff) + 1;
}
/**
 * Calculates the checksum for an elk message.
 * @see {M1-RS232-ASCII-Protocol} 4.1.6
 *
 * This is the hexadecimal two’s complement of the modulo-256 sum
 * of the ASCII values of all characters in the message excluding
 * the checksum itself and the CR-LF terminator at the end of the
 * message. Permissible characters are ASCII 0-9 and upper case A-F.
 * When all the characters are added to the Checksum, the value should equal 0.
 */
function calculateChecksum(input) {
    var inputBuffer = Buffer.from(input, 'ascii');
    // Sum all of the ASCII values.
    var sum = inputBuffer.reduce(function (accumulator, char) { return accumulator + char; }, 0);
    // Find the two's complement of the module-256 sum.
    var checksum = twosComplement(sum % 256);
    // Convert it to hex.
    return numberToHex(checksum, CHECKSUM_WIDTH);
}

/**
 * A regex expression that parses a raw message packet and captures:
 * 1. Packet length
 * 2. Message type
 * 3. Sub-message type
 * 4. Data
 * 5. Reserved
 * 6. Checksum
 * 7. Terminator
 */
var PACKET_REGEX = new RegExp("^(\\S{" + PACKET_LENGTH_WIDTH + "})(\\S)(\\S)(.*)(\\S{" + RESERVED_WIDTH + "})(\\S{" + CHECKSUM_WIDTH + "})(" + TERMINATOR + "|" + TERMINATOR[0] + "|" + TERMINATOR[1] + ")$");
/**
 * A message that is received from the Elk M1
 */
var ElkResponse = /** @class */ (function () {
    function ElkResponse(raw) {
        this.raw = raw;
        this.isWellFormed = false;
        this.isChecksumValid = false;
        this.isPacketLengthValid = false;
        this.data = '';
        var result = PACKET_REGEX.exec(raw);
        this.isWellFormed = !!result;
        if (result) {
            this.packetLength = result[1];
            this.messageType = result[2];
            this.subMessageType = result[3];
            this.data = result[4];
            this.reserved = result[5];
            this.checksum = result[6];
            this.terminator = result[7];
            this.expectedPacketLength = numberToHex(raw.length - PACKET_LENGTH_WIDTH - this.terminator.length, PACKET_LENGTH_WIDTH);
            this.expectedChecksum = calculateChecksum(raw.substring(0, raw.length - CHECKSUM_WIDTH - this.terminator.length));
            this.isChecksumValid = this.checksum === this.expectedChecksum;
            this.isPacketLengthValid = this.packetLength === this.expectedPacketLength;
        }
    }
    Object.defineProperty(ElkResponse.prototype, "command", {
        get: function () {
            if (!this.messageType || !this.subMessageType) {
                return null;
            }
            return this.messageType[0] + this.subMessageType[0];
        },
        enumerable: true,
        configurable: true
    });
    return ElkResponse;
}());

/**
 * A response received from the Elk M1 that is an unrecognized message.
 */
var UnknownElkResponse = /** @class */ (function (_super) {
    __extends$1(UnknownElkResponse, _super);
    function UnknownElkResponse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return UnknownElkResponse;
}(ElkResponse));

var AreaArmingStatus = /** @class */ (function () {
    function AreaArmingStatus(area, armingLevel, armUpState, alarmState) {
        this.area = area;
        this.armingLevel = armingLevel;
        this.armUpState = armUpState;
        this.alarmState = alarmState;
    }
    return AreaArmingStatus;
}());

/**
 * A response from the Elk M1 that reports the arming status for all areas.
 *
 * If the control’s area status changes, this message will be sent if
 * Global Option “Transmit Keypad Keys” is enabled.
 *
 * May be requested by sending a {@link ArmingStatusRequest}
 *
 * @see 4.2.13 Reply Arming Status Report Data (AS)
 */
var ArmingStatusReport = /** @class */ (function (_super) {
    __extends$1(ArmingStatusReport, _super);
    function ArmingStatusReport(raw) {
        var _this = _super.call(this, raw) || this;
        var armingLevels = Array.from(_this.data.substr(0, 8)).map(function (char) { return char.charCodeAt(0); });
        var armUpStates = Array.from(_this.data.substr(8, 8)).map(function (char) { return char.charCodeAt(0); });
        var alarmStates = Array.from(_this.data.substr(16, 8)).map(function (char) { return char.charCodeAt(0); });
        _this.areas = [1, 2, 3, 4, 5, 6, 7, 8].map(function (areaNumber, index) {
            return new AreaArmingStatus(areaNumber, armingLevels[index], armUpStates[index], alarmStates[index]);
        });
        return _this;
    }
    /**
     * Gets the arming status for an area
     * @param areaNumber The area number (1..8)
     */
    ArmingStatusReport.prototype.getAreaStatus = function (areaNumber) {
        return this.areas[areaNumber - 1];
    };
    Object.defineProperty(ArmingStatusReport.prototype, "exitTime", {
        /**
         * If any area has an {@link AreaArmingStatus.armUpState} of
         * {@link ArmUpState.ArmedTimer}, this will return the
         * exit time in seconds; Othwerise, this returns `null`
         */
        get: function () {
            if (this.reserved &&
                this.areas.find(function (areaStatus) { return areaStatus.armUpState === ArmUpState$1.ArmedTimer; })) {
                return parseInt(this.reserved, 10);
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ArmingStatusReport.prototype, "entranceTime", {
        /**
         * If any area has an {@link AreaArmingStatus.alarmState} of
         * {@link AlarmState.EntranceDelayActive} and no areas have an
         * {@link AreaArmingStatus.armUpState} of {@link ArmUpState.ArmedTimer},
         * this will return the entrance time in seconds; Othwerise, this
         * returns `null`.
         */
        get: function () {
            if (this.reserved &&
                this.exitTime === null &&
                this.areas.find(function (areaStatus) { return areaStatus.alarmState === AlarmState$1.EntranceDelayActive; })) {
                return parseInt(this.reserved, 10);
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    ArmingStatusReport.COMMAND = 'AS';
    return ArmingStatusReport;
}(ElkResponse));

/**
 * Send ASCII String To IP Address
 *
 * It is recommended this response NOT be used.
 *
 * The documentation on this particular "command" is very confusing.
 * Upper-cased commands are supposed to be responses from the M1,
 * but the documentation for this reads as those it's a command that
 * can be sent TO the panel. The example include message packets
 * which aren't even valid (they don't have checksums, the reserved
 * values, and the terminator).
 *
 * So I'm not entirely sure how this is supposed to be implemented.
 * For now it does some minimal parsing as a response message.
 *
 * TODO: Implement correctly?
 *
 * @see 4.3 Send ASCII String To IP Address (AP)
 */
var SendASCIIStringToIPAddress = /** @class */ (function (_super) {
    __extends$1(SendASCIIStringToIPAddress, _super);
    function SendASCIIStringToIPAddress(raw) {
        var _this = _super.call(this, raw) || this;
        _this.ipAddressNumber = parseInt(_this.data.substr(0, 1), 10);
        _this.textData = _this.data.substr(1);
        return _this;
    }
    SendASCIIStringToIPAddress.COMMAND = 'AP';
    return SendASCIIStringToIPAddress;
}(ElkResponse));

/**
 * Reports an alarm
 *
 * Reporting of alarms through the built on serial port 0 consists of an
 * ASCII string following the same data format of the digital dialer’s
 * Contact ID transmission. Programming one of the telephone numbers with
 * a dialer format set to “Ethernet” will enable the transmissions of the
 * alarm ASCII strings over the RS-232 serial port 0.
 * Available in M1 Version 4.2.8 and after.
 *
 * @see 4.4.1 Alarm Reporting (AR)
 */
var AlarmReport = /** @class */ (function (_super) {
    __extends$1(AlarmReport, _super);
    function AlarmReport(raw) {
        var _this = _super.call(this, raw) || this;
        _this.accountNumber = parseInt(_this.data.substr(0, 6), 10);
        _this.alarmCode = parseInt(_this.data.substr(6, 4), 10);
        _this.areaNumber = parseInt(_this.data.substr(10, 2), 10);
        _this.zoneNumber = parseInt(_this.data.substr(12, 3), 10);
        _this.ipAddressNumber = parseInt(_this.data.substr(15, 1), 10);
        return _this;
    }
    AlarmReport.COMMAND = 'AR';
    return AlarmReport;
}(ElkResponse));

/**
 * Alarm Reporting Test
 *
 * The Alarm Reporting Test string is sent every 15 minutes from the M1
 * as a keep alive message to the M1XEP Ethernet Module along with which
 * IP address to test. All IP addresses are set into the M1XEP module.
 *
 * @see 4.4.3 Alarm Reporting Test (AT)
 */
var AlarmReportTest = /** @class */ (function (_super) {
    __extends$1(AlarmReportTest, _super);
    function AlarmReportTest(raw) {
        var _this = _super.call(this, raw) || this;
        _this.ipAddressNumber = parseInt(_this.data.substr(0, 1), 10);
        return _this;
    }
    AlarmReportTest.COMMAND = 'AT';
    return AlarmReportTest;
}(ElkResponse));

/**
 * Ethernet Module Test
 *
 * The “XK” command is automatically sent every 30 seconds. This is
 * done regardless of whether an M1XEP Ethernet Module is present or
 * not. The XK command serves two purposes.
 *  1) It tests to see if a M1XEP Ethernet Module is connected to
 *     the Control.
 *  2) It includes the Control’s real time clock information (current
 *     Date and Time) for general purpose use, including but not limited
 *     to clock synchronization by a third party device.
 *
 * The expected response from a connected M1XEP Ethernet Module is “xk”.
 * However, the Control does not actually care or keep track of a missing
 * “xk” response UNLESS or UNTIL after a M1XEP Ethernet Module has been
 * properly enrolled with the Control. This can be accomplished via the
 * Bus Module Enrollment process (Keypad programming Menu 1) or by the RP
 * software). Once an M1XEP has been enrolled, the Control will now begin
 * tracking each response to an “XK” command, and it will display and log
 * an “Ethernet Trouble” message if an “xk” response is not received
 * within 120 seconds of the “XK” command. This response scenario is also
 * true for alarm reporting commands “AT” and “AR”. Basically, the M1XEP
 * will withhold sending the “xk” response if it should fail to complete
 * an alarm or restoral transmission after 2 attempts. This allows for
 * 1 transmission miss.
 *
 * NOTE: Control Firmware Version 4.32 and after includes the M1’s real
 * time clock information.
 *
 * @see 4.4.5 Ethernet Module Test (XK)
 */
var EthernetModuleTest = /** @class */ (function (_super) {
    __extends$1(EthernetModuleTest, _super);
    function EthernetModuleTest(raw) {
        var _this = _super.call(this, raw) || this;
        _this.seconds = parseInt(_this.data.substr(0, 2), 10);
        _this.minutes = parseInt(_this.data.substr(2, 2), 10);
        _this.hour = parseInt(_this.data.substr(4, 2), 10);
        _this.dayOfWeek = parseInt(_this.data.substr(6, 1), 10);
        _this.dayOfMonth = parseInt(_this.data.substr(7, 2), 10);
        _this.monthOfYear = parseInt(_this.data.substr(9, 2), 10);
        _this.year = 2000 + parseInt(_this.data.substr(11, 2), 10);
        _this.isDst = _this.data.substr(13, 1) === '1';
        _this.is12hourClockMode = _this.data.substr(14, 1) === '1';
        _this.isDateModeDayFirst = _this.data.substr(15, 1) === '1';
        // TODO: What to do with this? I'm not sure we have any way of
        // know which timezone we're dealing with. And it's not UTC.
        _this.date = new Date(Date.UTC(_this.year, _this.monthOfYear - 1, // JavaScript uses 0-based months.
        _this.dayOfMonth, _this.hour, _this.minutes, _this.seconds));
        return _this;
    }
    EthernetModuleTest.COMMAND = 'XK';
    return EthernetModuleTest;
}(ElkResponse));

/**
 * Reply Alarm By Zone Report Data
 *
 * May be requested by sending a {@link AlarmByZoneRequest}
 *
 * @see 4.5.1 Reply Alarm By Zone Report Data (AZ)
 */
var AlarmByZoneReport = /** @class */ (function (_super) {
    __extends$1(AlarmByZoneReport, _super);
    function AlarmByZoneReport(raw) {
        var _this = _super.call(this, raw) || this;
        _this.zones = Array.from(_this.data).map(function (char) { return char.charCodeAt(0); });
        _this.zonesInAlarm = _this.zones.reduce(function (alarmedZones, current, index) {
            if (current !== ZoneDefinition$1.Disabled) {
                return __spreadArrays(alarmedZones, [index + 1]);
            }
            return alarmedZones;
        }, []);
        return _this;
    }
    AlarmByZoneReport.prototype.getZoneAlarm = function (zoneNumber) {
        return this.zones[zoneNumber - 1];
    };
    Object.defineProperty(AlarmByZoneReport.prototype, "hasAlarms", {
        get: function () {
            return this.zonesInAlarm.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    AlarmByZoneReport.COMMAND = 'AZ';
    return AlarmByZoneReport;
}(ElkResponse));

/**
 * Reply With Audio Data
 *
 * Sent as a response to {@link AudioDataRequest}
 *
 * @see 4.6.2 Reply With Audio Data (CA)
 */
var AudioDataReply = /** @class */ (function (_super) {
    __extends$1(AudioDataReply, _super);
    function AudioDataReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.zone = parseInt(_this.data.substr(0, 2), 10);
        _this.isPowered = _this.data.substr(2, 1) === '1';
        _this.source = parseInt(_this.data.substr(3, 2), 10);
        _this.volume = parseInt(_this.data.substr(5, 3), 10);
        _this.bass = parseInt(_this.data.substr(8, 3), 10);
        _this.treble = parseInt(_this.data.substr(11, 3), 10);
        _this.isLoudness = _this.data.substr(14, 1) === '1';
        _this.balance = parseInt(_this.data.substr(15, 3), 10);
        _this.partyMode = parseInt(_this.data.substr(18, 1), 10);
        _this.isDoNotDisturb = _this.data.substr(19, 1) === '1';
        return _this;
    }
    AudioDataReply.COMMAND = 'CA';
    return AudioDataReply;
}(ElkResponse));

/**
 * Output Change Update
 *
 * This transmission update option transmits the updated status whenever
 * it changes and is enabled by setting the location TRUE in the M1 Control
 * Global Programming Locations 37.
 * Example: “Xmit OutputChgs–ASCII” (Yes or No)
 *
 * The Output Change Update will also be transmitted out M1XSP Serial Port
 * Expanders that are configured in the Generic Mode.
 *
 * @see 4.7 Output Change Update (CC)
 */
var OutputChangeUpdate = /** @class */ (function (_super) {
    __extends$1(OutputChangeUpdate, _super);
    function OutputChangeUpdate(raw) {
        var _this = _super.call(this, raw) || this;
        _this.outputNumber = parseInt(_this.data.substr(0, 3), 10);
        _this.isOn = _this.data.substr(3, 1) === '1';
        return _this;
    }
    OutputChangeUpdate.COMMAND = 'CC';
    return OutputChangeUpdate;
}(ElkResponse));

/**
 * Outgoing Audio Command
 *
 * A response to {@link AudioCommandIncoming}
 *
 * @see 4.8.3 Outgoing Audio Command (CD)
 */
var AudioCommandOutgoing = /** @class */ (function (_super) {
    __extends$1(AudioCommandOutgoing, _super);
    function AudioCommandOutgoing(raw) {
        var _this = _super.call(this, raw) || this;
        _this.audioCommand = parseInt(_this.data.substr(0, 2), 10);
        _this.audioSource = parseInt(_this.data.substr(2, 2), 10);
        _this.audioZone = parseInt(_this.data.substr(4, 2), 10);
        _this.value = parseInt(_this.data.substr(6, 3), 10);
        return _this;
    }
    AudioCommandOutgoing.COMMAND = 'CD';
    return AudioCommandOutgoing;
}(ElkResponse));

/**
 * Control Output Status Report
 *
 * The control panel sends this message in response
 * to a {@link ControlOutputStatusRequest}. The data portion
 * of this message is 208 characters long, one character
 * for each output in order. The value will be: 0 (Off), 1 (On).
 *
 * @see 4.9.4 Control Output Status Report (CS)
 */
var ControlOutputStatusReport = /** @class */ (function (_super) {
    __extends$1(ControlOutputStatusReport, _super);
    function ControlOutputStatusReport(raw) {
        var _this = _super.call(this, raw) || this;
        _this.outputStatuses = Array.from(_this.data).map(function (char) { return char === '1'; });
        return _this;
    }
    ControlOutputStatusReport.prototype.isOutputOn = function (outputNumber) {
        return this.outputStatuses[outputNumber - 1];
    };
    ControlOutputStatusReport.COMMAND = 'CS';
    return ControlOutputStatusReport;
}(ElkResponse));

/**
 * Represents a custom value with the TimeOfDay type.
 */
var CustomTimeOfDayValue = /** @class */ (function () {
    function CustomTimeOfDayValue(hour, minutes) {
        this.hour = hour;
        this.minutes = minutes;
        this.format = CustomValueFormat$1.TimeOfDay;
    }
    CustomTimeOfDayValue.decode = function (input) {
        var decimalValue = parseInt(input, 10);
        var hexValue = decimalValue.toString(16);
        var hour = parseInt(hexValue.substr(0, 2), 16);
        var minutes = parseInt(hexValue.substr(2, 2), 16);
        return new CustomTimeOfDayValue(hour, minutes);
    };
    CustomTimeOfDayValue.prototype.encode = function () {
        var timeInHex = this.hour.toString(16).padStart(2, '0') + this.minutes.toString(16).padStart(2, '0');
        return parseInt(timeInHex, 16)
            .toString()
            .padStart(5, '0');
    };
    return CustomTimeOfDayValue;
}());

/**
 * Represents a custom value of Number or Timer type.
 */
var CustomNumberValue = /** @class */ (function () {
    function CustomNumberValue(value, format) {
        if (format === void 0) { format = CustomValueFormat$1.Number; }
        this.value = value;
        this.format = format;
        if (format === CustomValueFormat$1.TimeOfDay) {
            throw new Error('CustomNumberValue format must be Number or Timer. Use CustomTimeOfDayValue for TimeOfDay format.');
        }
    }
    CustomNumberValue.decode = function (input, format) {
        var decimalValue = parseInt(input, 10);
        return new CustomNumberValue(decimalValue, format);
    };
    CustomNumberValue.prototype.encode = function () {
        return this.value.toString().padStart(5, '0');
    };
    return CustomNumberValue;
}());

var SPLIT_ALL_REGEX = /.{1,6}/g;
/**
 * Reply With Custom Value
 *
 * Sent in response to a {@link CustomValueRead}
 * or {@link CustomValuesReadAll}
 *
 * @see 4.10.3 Reply With Custom Value (CR)
 */
var CustomValueReply = /** @class */ (function (_super) {
    __extends$1(CustomValueReply, _super);
    function CustomValueReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.valueNumber = parseInt(_this.data.substr(0, 2), 10);
        if (_this.valueNumber === 0) {
            // ALL values were returned.
            var matches = _this.data.substr(2).match(SPLIT_ALL_REGEX);
            _this.values = matches
                ? matches.map(function (chunk, index) { return CustomValueReply.decodeCustomValue(chunk.substr(0, 6)); })
                : [];
        }
        else {
            _this.values = [CustomValueReply.decodeCustomValue(_this.data.substr(2, 6))];
        }
        return _this;
    }
    CustomValueReply.decodeCustomValue = function (input) {
        var value = input.substr(0, 5);
        var format = parseInt(input.substr(5, 1), 10);
        return format === CustomValueFormat$1.TimeOfDay
            ? CustomTimeOfDayValue.decode(value)
            : CustomNumberValue.decode(value, format);
    };
    CustomValueReply.prototype.getCustomValue = function (valueNumber) {
        if (valueNumber === void 0) { valueNumber = 1; }
        return this.values[valueNumber - 1];
    };
    CustomValueReply.COMMAND = 'CR';
    return CustomValueReply;
}(ElkResponse));

/**
 * Reply Change User Code
 *
 * Response to {@link UserCodeChangeRequest}
 *
 * @see 4.11.2 Reply Change User Code (CU)
 */
var UserCodeChangeReply = /** @class */ (function (_super) {
    __extends$1(UserCodeChangeReply, _super);
    function UserCodeChangeReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.userCode = parseInt(_this.data.substr(0, 3), 10);
        _this.isSuccessful = _this.userCode > 0 && _this.userCode < 255;
        _this.isInvalidAuthorizationCode = _this.userCode === 0;
        _this.isDuplicateCode = _this.userCode === 255;
        _this.changeType = _this.reserved ? parseInt(_this.reserved[0], 10) : UserCodeChangeType$1.UserCode;
        return _this;
    }
    UserCodeChangeReply.COMMAND = 'CU';
    return UserCodeChangeReply;
}(ElkResponse));

/**
 * Reply With Counter Value Format
 *
 * Sent in response to a {@link CounterValuRead}
 *
 * 4.12.3 Reply With Counter Value Format (CV)
 */
var CounterValueReply = /** @class */ (function (_super) {
    __extends$1(CounterValueReply, _super);
    function CounterValueReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.counterNumber = parseInt(_this.data.substr(0, 2), 10);
        _this.value = parseInt(_this.data.substr(2, 5), 10);
        return _this;
    }
    CounterValueReply.COMMAND = 'CV';
    return CounterValueReply;
}(ElkResponse));

/**
 * Reply Lighting Device Status Data
 *
 * @see 4.14.2 Reply Lighting Device Status Data (DS)
 */
var LightingDeviceDataReply = /** @class */ (function (_super) {
    __extends$1(LightingDeviceDataReply, _super);
    function LightingDeviceDataReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.lightingDeviceNumber = parseInt(_this.data.substr(0, 3), 10);
        _this.lightingLevel = parseInt(_this.data.substr(3, 2), 10);
        if (_this.lightingLevel === 1) {
            _this.lightingLevel = 100;
        }
        return _this;
    }
    LightingDeviceDataReply.COMMAND = 'DS';
    return LightingDeviceDataReply;
}(ElkResponse));

/**
 * Send Entry/Exit Data
 *
 * This sends the entry 1 & 2 and exit 1 & 2 time data when the timers
 * start by area. When each exit timer expires an “EE” command is also
 * transmitted.
 * M1 Version 4.1.12, 5.1.12 or later.
 * Armed State available in 4.1.18, 5.1.18 or later.
 *
 * @see 4.15.1 Send Entry/Exit Data (EE)
 */
var ExntryExitTimer = /** @class */ (function (_super) {
    __extends$1(ExntryExitTimer, _super);
    function ExntryExitTimer(raw) {
        var _this = _super.call(this, raw) || this;
        _this.areaNumber = parseInt(_this.data.substr(0, 1), 10);
        _this.isEntry = _this.data.substr(1, 1) === '1';
        _this.timer1 = parseInt(_this.data.substr(2, 3), 10);
        _this.timer2 = parseInt(_this.data.substr(5, 3), 10);
        _this.armingLevel = _this.data.charCodeAt(8);
        return _this;
    }
    Object.defineProperty(ExntryExitTimer.prototype, "isExit", {
        get: function () {
            return !this.isEntry;
        },
        enumerable: true,
        configurable: true
    });
    ExntryExitTimer.COMMAND = 'EE';
    return ExntryExitTimer;
}(ElkResponse));

/**
 * Send Email Trigger
 *
 * This command allows the triggering of email transmissions from
 * the M1XEP Ethernet interface. This command originates in the M1
 * and is sent to the M1XEP through serial port 0 only.
 * M1 Version 4.2.8 and after.
 *
 * @see 4.16.1 Send Email Trigger Data (EM)
 */
var EmailSendTrigger = /** @class */ (function (_super) {
    __extends$1(EmailSendTrigger, _super);
    function EmailSendTrigger(raw) {
        var _this = _super.call(this, raw) || this;
        _this.emailAddressNumber = parseInt(_this.data.substr(0, 3), 10);
        return _this;
    }
    EmailSendTrigger.COMMAND = 'EM';
    return EmailSendTrigger;
}(ElkResponse));

/**
 * Matches on a user-entered code.
 */
var USER_CODE_REGEX = /^(0\d)(0\d)(0\d)(0\d)(0\d)(0\d)$/;
var UserCode = /** @class */ (function () {
    function UserCode(code, isProximityCard) {
        if (isProximityCard === void 0) { isProximityCard = false; }
        this.code = code;
        this.isProximityCard = isProximityCard;
    }
    UserCode.decode = function (input) {
        var userCodeMatch = input.match(USER_CODE_REGEX);
        if (userCodeMatch) {
            // The regex match result contains the entire string as index 0,
            // and each match as index 1..7. Each of those will be preceded by
            // a zero, so exclude those "0" characters and join them to get the
            // code.
            return new UserCode(userCodeMatch
                .slice(1, 7)
                .map(function (char) { return char[1]; })
                .join(''), false);
        }
        else {
            return new UserCode(input, true);
        }
    };
    UserCode.prototype.encode = function (width) {
        if (width === void 0) { width = 12; }
        if (this.isProximityCard) {
            return this.code.padStart(width, '0');
        }
        return Array.from(this.code)
            .map(function (char) { return "0" + char; })
            .join('')
            .padStart(width, '0');
    };
    return UserCode;
}());

/**
 * Send Valid User Number And Invalid User Code
 *
 * This ASCII Data Packet will be sent when a user code is entered
 * and a valid code is found. Only the valid user code number will be
 * returned. If a user code is not found in the M1’s User Code Data
 * Base, the code that was enter will be sent. If the User Code
 * Length is set to 4 digits, the invalid data packet will be sent
 * after 4 digits are entered, then repeated for each additional
 * invalid user code digit. If the User Code Length is set to 6
 * digits, the invalid data packet will be sent after 6 digits
 * are entered, then repeated for each additional invalid user
 * digit. If prox card data is enter, the packet will be sent
 * immediately. This data can be used by automation equipment
 * with its own user code data base. The automation equipment
 * would sent the appropriate arm/disarm command (“a0” to “a6”)
 * or output relay control commands (“cn”, “cf”, or “ct”) back
 * to the M1 after it has verified the proper code is in its data
 * base. Modified for 26 bit Weigand data cards and available in
 * M1 Version 4.2.8 and after.
 *
 * @see 4.17 Send Valid User Number And Invalid User Code (IC)
 */
var UserCodeEntry = /** @class */ (function (_super) {
    __extends$1(UserCodeEntry, _super);
    function UserCodeEntry(raw) {
        var _this = _super.call(this, raw) || this;
        _this.userCode = UserCode.decode(_this.data.substr(0, 12));
        _this.userNumber = parseInt(_this.data.substr(12, 3), 10);
        _this.keypadNumber = parseInt(_this.data.substr(15, 3), 10);
        return _this;
    }
    Object.defineProperty(UserCodeEntry.prototype, "isValidEntry", {
        get: function () {
            return this.userNumber !== 0;
        },
        enumerable: true,
        configurable: true
    });
    UserCodeEntry.COMMAND = 'IC';
    return UserCodeEntry;
}(ElkResponse));

/**
 * Installer Mode Exited
 *
 * This command is automatically sent through serial port 0 only
 * when the installer mode is terminated. This is done by pressing
 * the “*” key three times or the installer timer runs out. This
 * command is used by the M1XEP Ethernet Interface to know when to
 * reload M1 program data after an installer has done any keypad
 * programming. M1 Version 4.2.8 and after.
 *
 * @see 4.18.1 Send Installer Mode Exited (IE)
 */
var InstallerModeExited = /** @class */ (function (_super) {
    __extends$1(InstallerModeExited, _super);
    function InstallerModeExited() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InstallerModeExited.COMMAND = 'IE';
    return InstallerModeExited;
}(ElkResponse));

var SPLIT_DEVICE_IDS_REGEX = /.{1,6}/g;
/**
 * Reply Read Of Insteon Lighting Device Data
 *
 * @see 4.19.4 Reply Read Of Insteon Lighting Device Data (IR)
 */
var InsteonLightingDeviceStatusReply = /** @class */ (function (_super) {
    __extends$1(InsteonLightingDeviceStatusReply, _super);
    function InsteonLightingDeviceStatusReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.startingDeviceNumber = parseInt(_this.data.substr(0, 3), 10);
        _this.deviceCount = parseInt(_this.data.substr(3, 1), 10);
        _this.deviceIds = _this.data.substr(4).match(SPLIT_DEVICE_IDS_REGEX) || [];
        return _this;
    }
    Object.defineProperty(InsteonLightingDeviceStatusReply.prototype, "endingDeviceNumber", {
        get: function () {
            return this.startingDeviceNumber + this.deviceCount - 1;
        },
        enumerable: true,
        configurable: true
    });
    InsteonLightingDeviceStatusReply.COMMAND = 'IR';
    return InsteonLightingDeviceStatusReply;
}(ElkResponse));

/**
 * Reply With Keypad Areas
 *
 * @see 4.20.2 Reply With Keypad Areas (KA)
 */
var KeypadAreaAssignments = /** @class */ (function (_super) {
    __extends$1(KeypadAreaAssignments, _super);
    function KeypadAreaAssignments(raw) {
        var _this = _super.call(this, raw) || this;
        _this.areas = Array.from(_this.data.substr(0, 16)).map(function (area) { return parseInt(area, 10); });
        return _this;
    }
    KeypadAreaAssignments.prototype.getKeypadArea = function (keypad) {
        return this.areas[keypad - 1];
    };
    KeypadAreaAssignments.COMMAND = 'KA';
    return KeypadAreaAssignments;
}(ElkResponse));

/**
 * Keypad KeyChange Update
 *
 * @see 4.21 Keypad KeyChange Update (KC)
 */
var KeypadKeyChange = /** @class */ (function (_super) {
    __extends$1(KeypadKeyChange, _super);
    function KeypadKeyChange(raw) {
        var _this = _super.call(this, raw) || this;
        _this.keypadNumber = parseInt(_this.data.substr(0, 2), 10);
        _this.keyPressed = parseInt(_this.data.substr(2, 2), 10);
        _this.functionKeyIlluminations = Array.from(_this.data.substr(4, 6)).map(function (illumination) {
            return illumination.charCodeAt(0);
        });
        _this.isCodeRequiredToBypass = _this.data.substr(10, 1) === '1';
        _this.areaBeepAndChimeModes = Array.from(_this.data.substr(11, 8)).map(function (mode) {
            return mode.charCodeAt(0);
        });
        return _this;
    }
    KeypadKeyChange.prototype.getBeepAndChimeMode = function (areaNumber) {
        return this.areaBeepAndChimeModes[areaNumber - 1];
    };
    KeypadKeyChange.prototype.getFunctionKeyIllumination = function (keyNumber) {
        return this.functionKeyIlluminations[keyNumber - 1];
    };
    KeypadKeyChange.COMMAND = 'KC';
    return KeypadKeyChange;
}(ElkResponse));

/**
 * Reply Keypad Function Key Press
 *
 * @see 4.22.2 Reply Keypad Function Key Press (KF)
 */
var KeypadFunctionKeyPressReply = /** @class */ (function (_super) {
    __extends$1(KeypadFunctionKeyPressReply, _super);
    function KeypadFunctionKeyPressReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.keypadNumber = parseInt(_this.data.substr(0, 2), 10);
        _this.functionKey = _this.data.substr(2, 1).charCodeAt(0);
        _this.chimeModes = Array.from(_this.data.substr(3, 8)).map(function (char) { return char.charCodeAt(0); });
        return _this;
    }
    KeypadFunctionKeyPressReply.prototype.getChimeMode = function (areaNumber) {
        return this.chimeModes[areaNumber - 1];
    };
    KeypadFunctionKeyPressReply.COMMAND = 'KF';
    return KeypadFunctionKeyPressReply;
}(ElkResponse));

/**
 * System Log Data Update
 *
 * As the control log is written, the same information is
 *  sent out the RS-232 port. The log information will have
 * the ddd index value set to “000” to indicate a logging
 * entry.
 *
 * The log data may also be requested with the “ld”
 * (lower case “LD”) command below. Modified in M1 version 4.3.2
 *
 * The “System Log Data Update” transmission option, transmits the
 * updated status whenever it changes and is enabled by setting the
 * location TRUE in the M1 Control Global Programming Locations 35.
 * Example: “Xmit Event Log–ASCII” (Yes or No). The request for log
 * data “ld” is not controlled by this option.
 *
 * @see 4.23 System Log Data Update (LD)
 */
var SystemLogDataUpdate = /** @class */ (function (_super) {
    __extends$1(SystemLogDataUpdate, _super);
    function SystemLogDataUpdate(raw) {
        var _this = _super.call(this, raw) || this;
        _this.event = parseInt(_this.data.substr(0, 4), 10);
        _this.eventNumberData = parseInt(_this.data.substr(4, 3), 10);
        _this.areaNumber = parseInt(_this.data.substr(7, 1), 10);
        _this.hour = parseInt(_this.data.substr(8, 2), 10);
        _this.minutes = parseInt(_this.data.substr(10, 2), 10);
        _this.month = parseInt(_this.data.substr(12, 2), 10);
        _this.day = parseInt(_this.data.substr(14, 2), 10);
        _this.logIndex = parseInt(_this.data.substr(16, 3), 10);
        _this.dayOfWeek = parseInt(_this.data.substr(19, 1), 10);
        _this.year = 2000 + parseInt(_this.data.substr(20, 2), 10);
        return _this;
    }
    SystemLogDataUpdate.COMMAND = 'LD';
    return SystemLogDataUpdate;
}(ElkResponse));

var SPLIT_CHUNKS_REGEX = /.{1,3}/g;
/**
 * Reply Temperature Data
 *
 * @see 4.24.2 Reply Temperature Data (LW)
 */
var TemperatureData = /** @class */ (function (_super) {
    __extends$1(TemperatureData, _super);
    function TemperatureData(raw) {
        var _this = _super.call(this, raw) || this;
        var keypadMatches = _this.data.substr(0, 3 * 16).match(SPLIT_CHUNKS_REGEX);
        var zoneMatches = _this.data.substr(3 * 16).match(SPLIT_CHUNKS_REGEX);
        _this.keypadTemperatures = keypadMatches
            ? keypadMatches.map(function (temp) { return parseInt(temp, 10) - 40; })
            : [];
        _this.zoneTemperatures = zoneMatches ? zoneMatches.map(function (temp) { return parseInt(temp, 10) - 60; }) : [];
        return _this;
    }
    TemperatureData.prototype.getKeypadTemperature = function (keypadNumber) {
        return this.keypadTemperatures[keypadNumber - 1];
    };
    TemperatureData.prototype.getZoneSensorTemperature = function (zoneNumber) {
        return this.zoneTemperatures[zoneNumber - 1];
    };
    TemperatureData.COMMAND = 'LW';
    return TemperatureData;
}(ElkResponse));

/**
 * PLC Change Update
 *
 * Special: When an AllLightsOn, AllLightsOff, or AllUnitsOff
 * command is transmitted the Unit Code will equal 00, and the Level (LL)
 * will be:
 * * AllLightsOn = 02
 * * AllLightsOff = 07
 * * AllUnitsOff = 01
 *
 * This transmission update option transmits the updated status whenever
 * it changes and is enabled by setting the location TRUE in the M1
 * Control Global Programming Location 39.
 * Example: “Xmit Light Chgs– ASCII” (Yes or No)
 *
 * @see 4.25.2 PLC Change Update (PC)
 */
var PlcChangeUpdate = /** @class */ (function (_super) {
    __extends$1(PlcChangeUpdate, _super);
    function PlcChangeUpdate(raw) {
        var _this = _super.call(this, raw) || this;
        _this.houseCode = _this.data[0];
        _this.unitCode = parseInt(_this.data.substr(1, 2), 10);
        _this.level = parseInt(_this.data.substr(3, 2), 10);
        return _this;
    }
    PlcChangeUpdate.COMMAND = 'PC';
    return PlcChangeUpdate;
}(ElkResponse));

/**
 * Returned PLC status
 *
 * @see 4.25.6 Returned PLC status (PS)
 */
var PlcDeviceStatusReply = /** @class */ (function (_super) {
    __extends$1(PlcDeviceStatusReply, _super);
    function PlcDeviceStatusReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.bank = parseInt(_this.data[0], 10);
        _this.levels = Array.from(_this.data.substr(1, 64)).map(function (value) { return parseInt(value, 10); });
        return _this;
    }
    PlcDeviceStatusReply.COMMAND = 'PS';
    return PlcDeviceStatusReply;
}(ElkResponse));

/**
 * Reset Ethernet Module
 *
 * This command is originated from the M1 and causes the M1XEP
 * Ethernet Module to reset its processor and/or its IP address
 * to: 192.168.0.251. This can be used when the IP address of the
 * M1XEP is set to an unknown value. This is accessed through the
 * M1’s Keypad Global Installer Programming, Option 45, then enter
 * 96. M1 Version 4.3.7 and after.
 *
 * @see 4.26 Reset Ethernet Module (RE)
 */
var EthernetModuleReset = /** @class */ (function (_super) {
    __extends$1(EthernetModuleReset, _super);
    function EthernetModuleReset(raw) {
        var _this = _super.call(this, raw) || this;
        _this.isIpAddressReset = _this.data[0] === '1';
        return _this;
    }
    EthernetModuleReset.COMMAND = 'RE';
    return EthernetModuleReset;
}(ElkResponse));

/**
 * ELKRP software Connected
 *
 * The M1XEP sends the following ASCII command out to
 * all socket connected devices when ELK RP,
 * Upload/Download Software, disconnects from the M1
 *
 * @see 4.27 ELKRP Connected (RP)
 */
var ElkRPConnected = /** @class */ (function (_super) {
    __extends$1(ElkRPConnected, _super);
    function ElkRPConnected(raw) {
        var _this = _super.call(this, raw) || this;
        _this.connectMessageType = _this.data[1];
        return _this;
    }
    Object.defineProperty(ElkRPConnected.prototype, "isDisconnectBroadcast", {
        get: function () {
            return this.connectMessageType === '0';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElkRPConnected.prototype, "isPollReply", {
        get: function () {
            return this.connectMessageType === '1';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElkRPConnected.prototype, "isInitializing", {
        get: function () {
            return this.connectMessageType === '2';
        },
        enumerable: true,
        configurable: true
    });
    ElkRPConnected.COMMAND = 'RP';
    return ElkRPConnected;
}(ElkResponse));

/**
 * Reply Real Time Clock Data
 *
 * @see 4.28.2 Reply Real Time Clock Data (RR)
 */
var RealTimeClockDataReply = /** @class */ (function (_super) {
    __extends$1(RealTimeClockDataReply, _super);
    function RealTimeClockDataReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.seconds = parseInt(_this.data.substr(0, 2), 10);
        _this.minutes = parseInt(_this.data.substr(2, 2), 10);
        _this.hour = parseInt(_this.data.substr(4, 2), 10);
        _this.dayOfWeek = parseInt(_this.data.substr(6, 1), 10);
        _this.dayOfMonth = parseInt(_this.data.substr(7, 2), 10);
        _this.monthOfYear = parseInt(_this.data.substr(9, 2), 10);
        _this.year = 2000 + parseInt(_this.data.substr(11, 2), 10);
        _this.isDst = _this.data.substr(13, 1) === '1';
        _this.is12hourClockMode = _this.data.substr(14, 1) === '1';
        _this.isDateModeDayFirst = _this.data.substr(15, 1) === '1';
        // TODO: What to do with this? I'm not sure we have any way of
        // know which timezone we're dealing with. And it's not UTC.
        _this.date = new Date(Date.UTC(_this.year, _this.monthOfYear - 1, // JavaScript uses 0-based months.
        _this.dayOfMonth, _this.hour, _this.minutes, _this.seconds));
        return _this;
    }
    RealTimeClockDataReply.COMMAND = 'RR';
    return RealTimeClockDataReply;
}(ElkResponse));

/**
 * Reply With ASCII String Text Descriptions
 *
 * Sent as a response to {@link TextDescriptionRequest}
 *
 * @see 4.29.2 Reply With ASCII String Text Descriptions (SD)
 */
var TextDescriptionReply = /** @class */ (function (_super) {
    __extends$1(TextDescriptionReply, _super);
    function TextDescriptionReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.textType = parseInt(_this.data.substr(0, 2), 10);
        _this.address = parseInt(_this.data.substr(2, 3), 10);
        _this.text = _this.data.substr(5, 16).trim();
        if (_this.text.charCodeAt(0) > 127) {
            // Note: The high bit of the first character in the text string may be set as the
            // “Show On Keypad” bit. Mask out the high bit for proper ASCII display.
            _this.text = String.fromCharCode(_this.text.charCodeAt(0) - 128) + _this.text.substr(1);
        }
        return _this;
    }
    TextDescriptionReply.COMMAND = 'SD';
    return TextDescriptionReply;
}(ElkResponse));

/**
 * Reply System Trouble Status
 *
 * This command allows automation equipment to poll
 * for system trouble status. Firmware revision 4.5.4,
 * 5.1.4 and after. This message will automatically
 * be sent upon a trouble status change.
 *
 * @see 4.30.2 Reply System Trouble Status (SS)
 */
var SystemTroubleStatusReply = /** @class */ (function (_super) {
    __extends$1(SystemTroubleStatusReply, _super);
    function SystemTroubleStatusReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.troubles = SystemTroubleType$1.None;
        if (_this.data[0] === '1') {
            _this.troubles |= SystemTroubleType$1.ACFail;
        }
        if (_this.data[1] !== '0') {
            _this.troubles |= SystemTroubleType$1.BoxTamper;
            _this.boxTamperTroubleZone = _this.data.charCodeAt(1) - 48;
        }
        if (_this.data[2] === '1') {
            _this.troubles |= SystemTroubleType$1.FailToCommunicate;
        }
        if (_this.data[3] === '1') {
            _this.troubles |= SystemTroubleType$1.EEPromMemoryError;
        }
        if (_this.data[4] === '1') {
            _this.troubles |= SystemTroubleType$1.LowBatteryControl;
        }
        if (_this.data[5] !== '0') {
            _this.troubles |= SystemTroubleType$1.TransmitterLowBattery;
            _this.transmitterLowBatteryTroubleZone = _this.data.charCodeAt(5) - 48;
        }
        if (_this.data[6] === '1') {
            _this.troubles |= SystemTroubleType$1.OverCurrent;
        }
        if (_this.data[7] === '1') {
            _this.troubles |= SystemTroubleType$1.TelephoneFault;
        }
        if (_this.data[9] === '1') {
            _this.troubles |= SystemTroubleType$1.Output2;
        }
        if (_this.data[10] === '1') {
            _this.troubles |= SystemTroubleType$1.MissingKeypad;
        }
        if (_this.data[11] === '1') {
            _this.troubles |= SystemTroubleType$1.ZoneExpander;
        }
        if (_this.data[12] === '1') {
            _this.troubles |= SystemTroubleType$1.OutputExpander;
        }
        if (_this.data[14] === '1') {
            _this.troubles |= SystemTroubleType$1.ELKRPRemoteAccess;
        }
        if (_this.data[16] === '1') {
            _this.troubles |= SystemTroubleType$1.CommonAreaNotArmed;
        }
        if (_this.data[17] === '1') {
            _this.troubles |= SystemTroubleType$1.FlashMemoryError;
        }
        if (_this.data[18] !== '0') {
            _this.troubles |= SystemTroubleType$1.SecurityAlert;
            _this.securityAlertTroubleZone = _this.data.charCodeAt(18) - 48;
        }
        if (_this.data[19] === '1') {
            _this.troubles |= SystemTroubleType$1.SerialPortExpander;
        }
        if (_this.data[20] !== '0') {
            _this.troubles |= SystemTroubleType$1.LostTransmitter;
            _this.lostTransmitterTroubleZone = _this.data.charCodeAt(20) - 48;
        }
        if (_this.data[21] === '1') {
            _this.troubles |= SystemTroubleType$1.GESmokeCleanMe;
        }
        if (_this.data[22] === '1') {
            _this.troubles |= SystemTroubleType$1.EthernetTrouble;
        }
        if (_this.data[31] === '1') {
            _this.troubles |= SystemTroubleType$1.DisplayMessageInKeypadLine1;
        }
        if (_this.data[32] === '1') {
            _this.troubles |= SystemTroubleType$1.DisplayMessageInKeypadLine2;
        }
        if (_this.data[33] !== '0') {
            _this.troubles |= SystemTroubleType$1.FireTrouble;
            _this.fireTroubleZone = _this.data.charCodeAt(33) - 48;
        }
        return _this;
    }
    SystemTroubleStatusReply.COMMAND = 'SS';
    return SystemTroubleStatusReply;
}(ElkResponse));

/**
 * Reply With Requested Temperature
 *
 * @see 4.31.2 Reply With Requested Temperature (ST)
 */
var TemperatureReply = /** @class */ (function (_super) {
    __extends$1(TemperatureReply, _super);
    function TemperatureReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.deviceType = parseInt(_this.data.substr(0, 1), 10);
        _this.deviceNumber = parseInt(_this.data.substr(1, 2), 10);
        _this.temperature = parseInt(_this.data.substr(3, 3), 10);
        if (_this.deviceType === TemperatureDeviceType$1.TemperatureProbe) {
            _this.temperature -= 60;
        }
        else if (_this.deviceType === TemperatureDeviceType$1.Keypad) {
            _this.temperature -= 40;
        }
        return _this;
    }
    TemperatureReply.COMMAND = 'ST';
    return TemperatureReply;
}(ElkResponse));

/**
 * Tasks Change Update
 *
 * This transmission update option transmits the updated status whenever
 * it changes and is enabled by setting the location TRUE in the M1 Control
 * Global Programming Location 38. Example: “Xmit Task Chgs – ASCII” (Yes
 * or No)
 *
 * @see 4.33 Tasks Change Update (TC)
 */
var TaskChangeUpdate = /** @class */ (function (_super) {
    __extends$1(TaskChangeUpdate, _super);
    function TaskChangeUpdate(raw) {
        var _this = _super.call(this, raw) || this;
        _this.taskNNumber = parseInt(_this.data.substr(0, 3), 10);
        return _this;
    }
    TaskChangeUpdate.COMMAND = 'TC';
    return TaskChangeUpdate;
}(ElkResponse));

/**
 * Reply Thermostat Data
 *
 * @see 4.35.2 Reply Thermostat Data (TR)
 */
var ThermostatData = /** @class */ (function (_super) {
    __extends$1(ThermostatData, _super);
    function ThermostatData(raw) {
        var _this = _super.call(this, raw) || this;
        _this.thermostatNumber = parseInt(_this.data.substr(0, 2), 10);
        _this.thermostatMode = _this.data.charCodeAt(2);
        _this.thermostatHold = _this.data[3] === '1';
        _this.thermostatFanOn = _this.data[4] === '1';
        _this.temperature = parseInt(_this.data.substr(5, 2), 10) || undefined;
        _this.heatSetPoint = parseInt(_this.data.substr(7, 2), 10) || undefined;
        _this.coolSetPoint = parseInt(_this.data.substr(9, 2), 10) || undefined;
        _this.humidity = parseInt(_this.data.substr(11, 2), 10) || undefined;
        return _this;
    }
    ThermostatData.COMMAND = 'TR';
    return ThermostatData;
}(ElkResponse));

/**
 * Reply - M1 to PC with Omnistat 2 ASCII Hex data
 *
 * This is the reply from the M1XSP connected to the HAI Omnistat
 * 2 HVAC Thermostat. M1 version 5.1.9 or later is required for
 * this command.
 *
 * @see 4.35.5 Reply - M1 to PC with Omnistat 2 ASCII Hex data (T2)
 */
var Omnistat2Reply = /** @class */ (function (_super) {
    __extends$1(Omnistat2Reply, _super);
    function Omnistat2Reply() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Omnistat2Reply.COMMAND = 'T2';
    return Omnistat2Reply;
}(ElkResponse));

function versionsToString(major, minor, patch) {
    return major.toString().padStart(2, '0') + "." + minor
        .toString()
        .padStart(2, '0') + "." + patch.toString().padStart(2, '0');
}
/**
 * Reply M1 Version Number
 *
 * Response to {@link VersionNumberRequest}
 *
 * @see 4.36.2 Reply M1 Version Number (VN)
 */
var VersionNumberReply = /** @class */ (function (_super) {
    __extends$1(VersionNumberReply, _super);
    function VersionNumberReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.m1Major = parseInt(_this.data.substr(0, 2), 16);
        _this.m1Minor = parseInt(_this.data.substr(2, 2), 16);
        _this.m1Patch = parseInt(_this.data.substr(4, 2), 16);
        _this.m1xepMajor = parseInt(_this.data.substr(6, 2), 16);
        _this.m1xepMinor = parseInt(_this.data.substr(8, 2), 16);
        _this.m1xepPatch = parseInt(_this.data.substr(10, 2), 16);
        return _this;
    }
    Object.defineProperty(VersionNumberReply.prototype, "m1Version", {
        get: function () {
            return versionsToString(this.m1Major, this.m1Minor, this.m1Patch);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VersionNumberReply.prototype, "m1XepVersion", {
        get: function () {
            return versionsToString(this.m1xepMajor, this.m1xepMinor, this.m1xepPatch);
        },
        enumerable: true,
        configurable: true
    });
    VersionNumberReply.COMMAND = 'VN';
    return VersionNumberReply;
}(ElkResponse));

/**
 * Reply With Valid User Code Areas
 *
 * @see 4.37.2 Reply With Valid User Code Areas (UA)
 */
var UserCodeAreasReply = /** @class */ (function (_super) {
    __extends$1(UserCodeAreasReply, _super);
    function UserCodeAreasReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.userCode = _this.data.substr(0, 6);
        var areaBits = parseInt(_this.data.substr(6, 2), 16).toString(2);
        _this.areas = Array.from(areaBits).map(function (bit) { return bit === '1'; });
        _this.diagnosticData = _this.data.substr(8, 8);
        _this.userCodeLength = parseInt(_this.data.substr(16, 1), 10);
        _this.userCodeType = _this.data.charCodeAt(17);
        _this.temperatureMode = _this.data[18];
        return _this;
    }
    UserCodeAreasReply.prototype.isValidForArea = function (areaNumber) {
        return this.areas[areaNumber - 1];
    };
    UserCodeAreasReply.COMMAND = 'UA';
    return UserCodeAreasReply;
}(ElkResponse));

/**
 * This message is used to inform User Interfaces that an alarm
 * memory is present and must be cleared before an arm command will arm the system.
 *
 * @see 4.38 Alarm Memory Update (AM)
 */
var AlarmMemoryUpdate = /** @class */ (function (_super) {
    __extends$1(AlarmMemoryUpdate, _super);
    function AlarmMemoryUpdate(raw) {
        var _this = _super.call(this, raw) || this;
        // The alarm memory response uses the reserved characters as
        // part of it's data (or depending on how you look at it,
        // doesn't *have* the reserved characters.
        var data = _this.data + _this.reserved;
        _this.areas = Array.from(data.substr(0, 8)).map(function (char) { return char === '1'; });
        return _this;
    }
    /**
     * Returns a value indicating whether there is an alarm memory
     * present in the given area.
     * @param areaNumber The area number (1..8)
     */
    AlarmMemoryUpdate.prototype.isAlarmMemoryPresent = function (areaNumber) {
        return this.areas[areaNumber - 1];
    };
    AlarmMemoryUpdate.COMMAND = 'AM';
    return AlarmMemoryUpdate;
}(ElkResponse));

var ZoneStatus = /** @class */ (function () {
    function ZoneStatus(logicalState, physicalState) {
        this.logicalState = logicalState;
        this.physicalState = physicalState;
        this.hexValue = parseInt(logicalState.toString(2).padStart(2, '0') + physicalState.toString(2).padStart(2, '0'), 2)
            .toString(16)
            .toUpperCase();
    }
    ZoneStatus.parse = function (hexValue) {
        var statusBits = parseInt(hexValue, 16)
            .toString(2)
            .padStart(4, '0');
        var logicalState = parseInt(statusBits.substr(0, 2), 2);
        var physicalState = parseInt(statusBits.substr(2, 2), 2);
        return new ZoneStatus(logicalState, physicalState);
    };
    return ZoneStatus;
}());

/**
 * Zone Change Update
 *
 * This transmission update option transmits the updated status
 * whenever it changes and is enabled by setting the location
 * TRUE in the M1 Control Global Programming Location 36.
 * Example: “Xmit Zone Chgs–ASCII” (Yes or No)
 *
 * @see 4.39 Zone Change Update (ZC)
 */
var ZoneChangeUpdate = /** @class */ (function (_super) {
    __extends$1(ZoneChangeUpdate, _super);
    function ZoneChangeUpdate(raw) {
        var _this = _super.call(this, raw) || this;
        _this.zoneNumber = parseInt(_this.data.substr(0, 3), 10);
        _this.zoneStatus = ZoneStatus.parse(_this.data[3]);
        return _this;
    }
    ZoneChangeUpdate.COMMAND = 'ZC';
    return ZoneChangeUpdate;
}(ElkResponse));

/**
 * Reply With Bypassed Zone State
 *
 * @see 4.40.2 Reply With Bypassed Zone State (ZB)
 */
var ZoneBypassReply = /** @class */ (function (_super) {
    __extends$1(ZoneBypassReply, _super);
    function ZoneBypassReply(raw) {
        var _this = _super.call(this, raw) || this;
        _this.zoneNumber = parseInt(_this.data.substr(0, 3), 10);
        _this.isBypassed = _this.data[3] === '1';
        return _this;
    }
    ZoneBypassReply.COMMAND = 'ZB';
    return ZoneBypassReply;
}(ElkResponse));

/**
 * Zone Partition Report
 *
 * The control panel sends this message in response to a
 * Zone Partition Request. The data portion, D, of this
 * message is 208 characters long, one character for each
 * zone in order. The value will be from 1-8.
 *
 * @see 4.40.4 Zone Partition Report (ZP)
 */
var ZonePartitionReport = /** @class */ (function (_super) {
    __extends$1(ZonePartitionReport, _super);
    function ZonePartitionReport(raw) {
        var _this = _super.call(this, raw) || this;
        _this.zonePartitions = Array.from(_this.data).map(function (char) { return parseInt(char, 10); });
        return _this;
    }
    ZonePartitionReport.prototype.getZoneArea = function (zoneNumber) {
        return this.zonePartitions[zoneNumber - 1];
    };
    ZonePartitionReport.COMMAND = 'ZP';
    return ZonePartitionReport;
}(ElkResponse));

/**
 * Zone Status Report
 *
 * The control panel sends this message in response
 * to a Zone Status Request. The data portion of this
 * message is 208 characters long, one character for
 * each zone in order. Each character is the sum of
 * all applicable status values, expressed in hexadecimal,
 * using ASCII characters 0-9 and A-F.
 * @see 4.40.6 Zone Status Report (ZS)
 */
var ZoneStatusReport = /** @class */ (function (_super) {
    __extends$1(ZoneStatusReport, _super);
    function ZoneStatusReport(raw) {
        var _this = _super.call(this, raw) || this;
        _this.zoneStatuses = Array.from(_this.data).map(function (char) { return ZoneStatus.parse(char); });
        return _this;
    }
    ZoneStatusReport.prototype.getZoneStatus = function (zoneNumber) {
        return this.zoneStatuses[zoneNumber - 1];
    };
    ZoneStatusReport.COMMAND = 'ZS';
    return ZoneStatusReport;
}(ElkResponse));

/**
 * Reply Zone Definition Data
 *
 * @see 4.41.2 Reply Zone Definition Data (ZD)
 */
var ZoneDefinitionData = /** @class */ (function (_super) {
    __extends$1(ZoneDefinitionData, _super);
    function ZoneDefinitionData(raw) {
        var _this = _super.call(this, raw) || this;
        _this.zoneDefinitions = Array.from(_this.data).map(function (char) { return char.charCodeAt(0); });
        return _this;
    }
    ZoneDefinitionData.prototype.getZoneDefinition = function (zoneNumber) {
        return this.zoneDefinitions[zoneNumber - 1];
    };
    ZoneDefinitionData.COMMAND = 'ZD';
    return ZoneDefinitionData;
}(ElkResponse));

/**
 * Reply Zone Analog Voltage Data
 *
 * @see 4.43.2 Reply Zone Analog Voltage Data (ZV)
 */
var ZoneVoltageData = /** @class */ (function (_super) {
    __extends$1(ZoneVoltageData, _super);
    function ZoneVoltageData(raw) {
        var _this = _super.call(this, raw) || this;
        _this.zoneNumber = parseInt(_this.data.substr(0, 3), 10);
        _this.zoneVoltage = parseInt(_this.data.substr(3, 3), 10) / 10;
        return _this;
    }
    ZoneVoltageData.COMMAND = 'ZV';
    return ZoneVoltageData;
}(ElkResponse));

/**
 * Reply Programming Of Insteon Lighting Device Data
 *
 * Note: Insteon Lighting Device 193 to 256 corresponds to
 * Insteon Groups 1 – 64.
 *
 * @see 4.44 Reply Programming Of Insteon Lighting Device Data (IP)
 */
var InsteonLightingDeviceProgrammed = /** @class */ (function (_super) {
    __extends$1(InsteonLightingDeviceProgrammed, _super);
    function InsteonLightingDeviceProgrammed(raw) {
        var _this = _super.call(this, raw) || this;
        _this.startingDeviceNumber = parseInt(_this.data.substr(0, 3), 10);
        _this.deviceCount = parseInt(_this.data.substr(3, 1), 10);
        return _this;
    }
    Object.defineProperty(InsteonLightingDeviceProgrammed.prototype, "endingDeviceNumber", {
        get: function () {
            return this.startingDeviceNumber + this.deviceCount - 1;
        },
        enumerable: true,
        configurable: true
    });
    InsteonLightingDeviceProgrammed.COMMAND = 'IP';
    return InsteonLightingDeviceProgrammed;
}(ElkResponse));

var _a;
var RESPONSE_MAP = (_a = {},
    _a[ArmingStatusReport.COMMAND] = ArmingStatusReport,
    _a[SendASCIIStringToIPAddress.COMMAND] = SendASCIIStringToIPAddress,
    _a[AlarmReport.COMMAND] = AlarmReport,
    _a[AlarmReportTest.COMMAND] = AlarmReportTest,
    _a[EthernetModuleTest.COMMAND] = EthernetModuleTest,
    _a[AlarmByZoneReport.COMMAND] = AlarmByZoneReport,
    _a[AudioDataReply.COMMAND] = AudioDataReply,
    _a[OutputChangeUpdate.COMMAND] = OutputChangeUpdate,
    _a[AudioCommandOutgoing.COMMAND] = AudioCommandOutgoing,
    _a[ControlOutputStatusReport.COMMAND] = ControlOutputStatusReport,
    _a[CustomValueReply.COMMAND] = CustomValueReply,
    _a[UserCodeChangeReply.COMMAND] = UserCodeChangeReply,
    _a[CounterValueReply.COMMAND] = CounterValueReply,
    _a[LightingDeviceDataReply.COMMAND] = LightingDeviceDataReply,
    _a[ExntryExitTimer.COMMAND] = ExntryExitTimer,
    _a[EmailSendTrigger.COMMAND] = EmailSendTrigger,
    _a[UserCodeEntry.COMMAND] = UserCodeEntry,
    _a[InstallerModeExited.COMMAND] = InstallerModeExited,
    _a[InsteonLightingDeviceStatusReply.COMMAND] = InsteonLightingDeviceStatusReply,
    _a[KeypadAreaAssignments.COMMAND] = KeypadAreaAssignments,
    _a[KeypadKeyChange.COMMAND] = KeypadKeyChange,
    _a[KeypadFunctionKeyPressReply.COMMAND] = KeypadFunctionKeyPressReply,
    _a[SystemLogDataUpdate.COMMAND] = SystemLogDataUpdate,
    _a[TemperatureData.COMMAND] = TemperatureData,
    _a[PlcChangeUpdate.COMMAND] = PlcChangeUpdate,
    _a[PlcDeviceStatusReply.COMMAND] = PlcDeviceStatusReply,
    _a[EthernetModuleReset.COMMAND] = EthernetModuleReset,
    _a[ElkRPConnected.COMMAND] = ElkRPConnected,
    _a[RealTimeClockDataReply.COMMAND] = RealTimeClockDataReply,
    _a[TextDescriptionReply.COMMAND] = TextDescriptionReply,
    _a[SystemTroubleStatusReply.COMMAND] = SystemTroubleStatusReply,
    _a[TemperatureReply.COMMAND] = TemperatureReply,
    _a[TaskChangeUpdate.COMMAND] = TaskChangeUpdate,
    _a[ThermostatData.COMMAND] = ThermostatData,
    _a[Omnistat2Reply.COMMAND] = Omnistat2Reply,
    _a[VersionNumberReply.COMMAND] = VersionNumberReply,
    _a[UserCodeAreasReply.COMMAND] = UserCodeAreasReply,
    _a[AlarmMemoryUpdate.COMMAND] = AlarmMemoryUpdate,
    _a[ZoneChangeUpdate.COMMAND] = ZoneChangeUpdate,
    _a[ZoneBypassReply.COMMAND] = ZoneBypassReply,
    _a[ZonePartitionReport.COMMAND] = ZonePartitionReport,
    _a[ZoneStatusReport.COMMAND] = ZoneStatusReport,
    _a[ZoneDefinitionData.COMMAND] = ZoneDefinitionData,
    _a[ZoneVoltageData.COMMAND] = ZoneVoltageData,
    _a[InsteonLightingDeviceProgrammed.COMMAND] = InsteonLightingDeviceProgrammed // 4.44
,
    _a);
function parse(raw) {
    var command = raw.substr(2, 2);
    var ResponseClass = RESPONSE_MAP[command] || UnknownElkResponse;
    return new ResponseClass(raw);
}

/**
 * A message that is sent to the Elk M1
 */
var ElkCommand = /** @class */ (function () {
    function ElkCommand(messageType, subMessageType, data) {
        if (data === void 0) { data = ''; }
        this.messageType = messageType;
        this.subMessageType = subMessageType;
        this.data = data;
    }
    Object.defineProperty(ElkCommand.prototype, "raw", {
        get: function () {
            var message = "" + this.command + (this.data || '') + (this.reserved || RESERVED_DEFAULT);
            var packetLength = numberToHex(message.length + 2, PACKET_LENGTH_WIDTH);
            var checksum = calculateChecksum("" + packetLength + message);
            return "" + packetLength + message + checksum + TERMINATOR;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElkCommand.prototype, "command", {
        get: function () {
            return this.messageType + this.subMessageType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElkCommand.prototype, "reserved", {
        get: function () {
            return RESERVED_DEFAULT;
        },
        enumerable: true,
        configurable: true
    });
    return ElkCommand;
}());

/**
 * 4.5 Alarm By Zone Request (az)
 *
 * Request alarm by zone
 *
 * The control panel responds to this message with a
 * {@link AlarmByZoneReport}
 */
var AlarmByZoneRequest = /** @class */ (function (_super) {
    __extends$1(AlarmByZoneRequest, _super);
    function AlarmByZoneRequest() {
        return _super.call(this, 'a', 'z') || this;
    }
    return AlarmByZoneRequest;
}(ElkCommand));

/**
 * Alarm Report Acknowledge
 *
 * The Ethernet Module (M1XEP) will acknowledge the M1’s Alarm Report
 * transmission with the reply: 06ar0067<cr><lf>. This acknowledge
 * is sent to the M1 only if the central station’s server acknowledges
 * the Ethernet Module’s data packet.
 *
 * @see 4.4.2 Alarm Report Acknowledge (ar)
 */
var AlarmReportAcknowledge = /** @class */ (function (_super) {
    __extends$1(AlarmReportAcknowledge, _super);
    function AlarmReportAcknowledge() {
        return _super.call(this, 'a', 'r') || this;
    }
    return AlarmReportAcknowledge;
}(ElkCommand));

/**
 * Alarm Reporting Test Acknowledge
 *
 * If the Alarm Reporting Test if successful to the central station’s IP
 * address the Acknowledge message will be sent to the M1 from the
 * M1XEP: 06at0065<cr><lf>.
 *
 * @see 4.4.4 Alarm Reporting Test Acknowledge (at)
 */
var AlarmReportTestAcknowledge = /** @class */ (function (_super) {
    __extends$1(AlarmReportTestAcknowledge, _super);
    function AlarmReportTestAcknowledge() {
        return _super.call(this, 'a', 't') || this;
    }
    return AlarmReportTestAcknowledge;
}(ElkCommand));

/**
 * Arm or disarm an area.
 *
 * Note: Arming the control panel with zones open
 * will initiate “force arming” regardless of whether
 * force arming is enabled or disabled in the control panel.
 *
 * @see 4.2 Arm and Disarm Messages (a0..a8)
 */
var Arm = /** @class */ (function (_super) {
    __extends$1(Arm, _super);
    /**
     * @param armingLevel The arming level desired
     * @param areaNumber The area to be armed or disarmed
     * @param userCode The user code (a string of 4 or 6 digits)
     */
    function Arm(armingLevel, areaNumber, userCode) {
        var _this = _super.call(this, 'a', String.fromCharCode(armingLevel), areaNumber + userCode.padStart(6, '0')) || this;
        _this.armingLevel = armingLevel;
        _this.areaNumber = areaNumber;
        _this.userCode = userCode;
        return _this;
    }
    return Arm;
}(ElkCommand));

/**
 * Requests current arming status for all areas.
 *
 * The control panel responds to this message with a {@link ArmingStatusReport}
 *
 * @see 4.2.12 Arming Status Request (as)
 */
var ArmingStatusRequest = /** @class */ (function (_super) {
    __extends$1(ArmingStatusRequest, _super);
    function ArmingStatusRequest() {
        return _super.call(this, 'a', 's') || this;
    }
    return ArmingStatusRequest;
}(ElkCommand));

/**
 * Incoming Audio Command
 *
 * An M1XEP Ethernet Module is required to intercept the “cd” command.
 * These commands are sent into the M1XEP via the Ethernet connection
 * and passed through to the M1. The M1XEP builds custom audio commands
 * to control the audio equipment and sends these commands to the audio
 * equipment via ethernet. An IP232 Ethernet Module may be required at
 * the audio equipment to received the commands if no Ethernet Port is
 * available on the audio equipment. The incoming “cd” command can
 * trigger Rules in the M1 which can fire outgoing audio equipment
 * “CD” commands or other control Rules. ELKRP downloads the Audio
 * Equipment Command tables into the M1XEP according to the Audio
 * Equipment Manufacturer. M1 version 4.1.11, 5.1.11 or later is required.
 *
 * @see 4.8.1 Incoming Audio Command (cd)
 */
var AudioCommandIncoming = /** @class */ (function (_super) {
    __extends$1(AudioCommandIncoming, _super);
    function AudioCommandIncoming(audioCommand, audioSource, audioZone, value) {
        if (value === void 0) { value = 0; }
        var _this = _super.call(this, 'c', 'd', audioCommand.toString().padStart(2, '0') +
            audioSource.toString().padStart(2, '0') +
            audioZone.toString().padStart(2, '0') +
            value.toString().padStart(3, '0')) || this;
        _this.audioCommand = audioCommand;
        _this.audioSource = audioSource;
        _this.audioZone = audioZone;
        _this.value = value;
        return _this;
    }
    return AudioCommandIncoming;
}(ElkCommand));

/**
 * Request Audio Data
 *
 * The control panel responds to this message with a {@link AudioDataReply}
 *
 * @see 4.6.1 Request Audio Data (ca)
 */
var AudioDataRequest = /** @class */ (function (_super) {
    __extends$1(AudioDataRequest, _super);
    function AudioDataRequest(zoneNumber) {
        var _this = _super.call(this, 'c', 'a', zoneNumber.toString().padStart(2, '0')) || this;
        _this.zoneNumber = zoneNumber;
        return _this;
    }
    return AudioDataRequest;
}(ElkCommand));

/**
 * Control Output off
 *
 * @see 4.9.1 Control Output off (cf)
 */
var ControlOutputOff = /** @class */ (function (_super) {
    __extends$1(ControlOutputOff, _super);
    function ControlOutputOff(output) {
        var _this = _super.call(this, 'c', 'f', output.toString().padStart(3, '0')) || this;
        _this.output = output;
        return _this;
    }
    return ControlOutputOff;
}(ElkCommand));

/**
 * Control Output On
 *
 * @see 4.9.2 Control Output On (cn)
 */
var ControlOutputOn = /** @class */ (function (_super) {
    __extends$1(ControlOutputOn, _super);
    function ControlOutputOn(output, duration) {
        if (duration === void 0) { duration = 0; }
        var _this = _super.call(this, 'c', 'n', output.toString().padStart(3, '0') + duration.toString().padStart(5, '0')) || this;
        _this.output = output;
        _this.duration = duration;
        return _this;
    }
    return ControlOutputOn;
}(ElkCommand));

/**
 * Control Output Status Request
 *
 * The control panel responds with a {@link ControlOutputStatusReport} Report for all 208 outputs.
 *
 * @see 4.9.3 Control Output Status Request (cs)
 */
var ControlOutputStatusRequest = /** @class */ (function (_super) {
    __extends$1(ControlOutputStatusRequest, _super);
    function ControlOutputStatusRequest() {
        return _super.call(this, 'c', 's') || this;
    }
    return ControlOutputStatusRequest;
}(ElkCommand));

/**
 * Control Output toggle
 *
 * @see 4.9.5 Control Output toggle (ct)
 */
var ControlOutputToggle = /** @class */ (function (_super) {
    __extends$1(ControlOutputToggle, _super);
    function ControlOutputToggle(output) {
        var _this = _super.call(this, 'c', 't', output.toString().padStart(3, '0')) || this;
        _this.output = output;
        return _this;
    }
    return ControlOutputToggle;
}(ElkCommand));

/**
 * Read Counter Value
 *
 * The control responds with {@link CounterValueReply}
 *
 * @see 4.12.1 Read Counter Value (cv)
 */
var CounterValueRead = /** @class */ (function (_super) {
    __extends$1(CounterValueRead, _super);
    function CounterValueRead(counterNumber) {
        var _this = _super.call(this, 'c', 'v', counterNumber.toString().padStart(2, '0')) || this;
        _this.counterNumber = counterNumber;
        if (counterNumber < 1 || counterNumber > 64) {
            throw new RangeError('Counter value number must be between 1 and 64');
        }
        return _this;
    }
    return CounterValueRead;
}(ElkCommand));

/**
 * Write Counter Value
 *
 * @see 4.12.2 Write Counter Value (cx)
 */
var CounterValueWrite = /** @class */ (function (_super) {
    __extends$1(CounterValueWrite, _super);
    function CounterValueWrite(counterNumber, value) {
        var _this = _super.call(this, 'c', 'x', counterNumber.toString().padStart(2, '0') + value.toString().padStart(5, '0')) || this;
        _this.counterNumber = counterNumber;
        _this.value = value;
        return _this;
    }
    return CounterValueWrite;
}(ElkCommand));

/**
 * Read Custom Value
 *
 * The control response with {@link CustomValueReply}
 *
 * @see 4.10.1 Read Custom Value (cr)
 */
var CustomValueRead = /** @class */ (function (_super) {
    __extends$1(CustomValueRead, _super);
    function CustomValueRead(valueNumber) {
        var _this = _super.call(this, 'c', 'r', valueNumber.toString().padStart(2, '0')) || this;
        _this.valueNumber = valueNumber;
        if (valueNumber < 0 || valueNumber > 20) {
            throw new RangeError('Custom value number must be between 0 and 20');
        }
        return _this;
    }
    return CustomValueRead;
}(ElkCommand));

/**
 * Write Custom Value
 *
 * @see 4.10.5 Write Custom Value (cw)
 */
var CustomValueWrite = /** @class */ (function (_super) {
    __extends$1(CustomValueWrite, _super);
    function CustomValueWrite(valueNumber, value) {
        var _this = _super.call(this, 'c', 'w', valueNumber.toString().padStart(2, '0') + value.encode()) || this;
        _this.valueNumber = valueNumber;
        _this.value = value;
        if (valueNumber < 0 || valueNumber > 20) {
            throw new RangeError('Custom value number must be between 0 and 20');
        }
        return _this;
    }
    return CustomValueWrite;
}(ElkCommand));

/**
 * Read ALL Custom Values
 *
 * The control response with {@link CustomValueReply}
 *
 * @see 4.10.2 Read ALL Custom Values (cp)
 */
var CustomValuesReadAll = /** @class */ (function (_super) {
    __extends$1(CustomValuesReadAll, _super);
    function CustomValuesReadAll() {
        return _super.call(this, 'c', 'p') || this;
    }
    return CustomValuesReadAll;
}(ElkCommand));

function encodeLineData(input) {
    // If there is no data, return the terminator and pad with dummy character.
    if (!input || !input.length) {
        return '^'.padEnd(16, 'x');
    }
    // If the input is less then the allowed length, add the terminator character
    // and pad with dummy characters.
    if (input.length < 16) {
        return (input + '^').padEnd(16, 'x');
    }
    // Otherwise, make sure the input is limited to 16 characters.
    return input.substr(0, 16);
}
/**
 * Display Text On LCD Screen of keypads
 *
 * This is a M1 received message to display ascii text on the bottom line
 * of the LCD display on the keypads in the area specified. Enter the line
 * terminator, “^”, as the ending character of the line display if less
 * than 16 characters are to be displayed. The message line, L1 or L2,
 * will need dummy characters to fill the rest of the line for 16
 * characters each line.
 *
 * @see 4.13 Display Text On LCD Screen (dm)
 */
var DisplayTextOnScreen = /** @class */ (function (_super) {
    __extends$1(DisplayTextOnScreen, _super);
    function DisplayTextOnScreen(areaNumber, firstLine, secondLine, clearOption, beep, timeout) {
        if (firstLine === void 0) { firstLine = ''; }
        if (secondLine === void 0) { secondLine = ''; }
        if (clearOption === void 0) { clearOption = !firstLine
            ? DisplayTextClearOption$1.Clear
            : DisplayTextClearOption$1.ClearWithStarKey; }
        if (beep === void 0) { beep = true; }
        if (timeout === void 0) { timeout = 0; }
        var _this = _super.call(this, 'd', 'm', areaNumber.toString() +
            clearOption.toString() +
            (beep ? '1' : '0') +
            (timeout || 0).toString().padStart(5, '0') +
            encodeLineData(firstLine) +
            encodeLineData(secondLine)) || this;
        _this.areaNumber = areaNumber;
        _this.firstLine = firstLine;
        _this.secondLine = secondLine;
        _this.clearOption = clearOption;
        _this.beep = beep;
        _this.timeout = timeout;
        return _this;
    }
    return DisplayTextOnScreen;
}(ElkCommand));

/**
 * Ethernet Module Test Acknowledge
 *
 * If the Ethernet Module is alive, it will reply back to the M1
 * with: 06xk0057<cr><lf>.
 *
 * @see 4.4.6 Ethernet Module Test Acknowledge (xk)
 */
var EthernetModuleTestAcknowledge = /** @class */ (function (_super) {
    __extends$1(EthernetModuleTestAcknowledge, _super);
    function EthernetModuleTestAcknowledge() {
        return _super.call(this, 'x', 'k') || this;
    }
    return EthernetModuleTestAcknowledge;
}(ElkCommand));

/**
 * Request Programming Of Insteon Lighting Device Data
 *
 * @see 4.19.5 Request Programming Of Insteon Lighting Device Data (ip)
 */
var InsteonLightingDeviceProgramRequest = /** @class */ (function (_super) {
    __extends$1(InsteonLightingDeviceProgramRequest, _super);
    function InsteonLightingDeviceProgramRequest(startingDeviceNumber, deviceIds) {
        var _this = _super.call(this, 'i', 'p', startingDeviceNumber.toString().padStart(3, '0') +
            deviceIds.length.toString() +
            deviceIds.map(function (id) { return id.padStart(6, '0'); }).join('')) || this;
        _this.startingDeviceNumber = startingDeviceNumber;
        _this.deviceIds = deviceIds;
        return _this;
    }
    return InsteonLightingDeviceProgramRequest;
}(ElkCommand));

/**
 * Request Read Of Insteon Lighting Device Data
 *
 * This command allows the M1 to poll single light devices to obtain
 * their on, off, dim status. This will be an automatic command issued
 * from the M1 to the M1XSP Type modules that connect to lighting devices.
 * Note: Only single light devices can be polled for status. Groups and
 * scenes will not return valid data. Enable the “2 Way” Poll setting for
 * the device to be polled. M1 Version 4.3.9 and after. This command
 * cannot be used by automation equipment.
 *
 * @see 4.19.3 Request Read Of Insteon Lighting Device Data (ir)
 */
var InsteonLightingDeviceStatusRequest = /** @class */ (function (_super) {
    __extends$1(InsteonLightingDeviceStatusRequest, _super);
    function InsteonLightingDeviceStatusRequest(startingDeviceNumber, deviceCount) {
        var _this = _super.call(this, 'i', 'r', startingDeviceNumber.toString().padStart(3, '0') + deviceCount.toString()) || this;
        _this.startingDeviceNumber = startingDeviceNumber;
        _this.deviceCount = deviceCount;
        return _this;
    }
    return InsteonLightingDeviceStatusRequest;
}(ElkCommand));

/**
 * Request Keypad Area Assignment
 *
 * This request command allows automation equipment to request
 * the Areas that all keypads are assigned to. The return string
 * contains a 16 byte array with keypad 1’s area at array index
 * 0 and keypad 15’s area in array index 15. M1 Version 4.2.5 and after.
 *
 * @see 4.20.1 Request Keypad Area Assignment (ka)
 */
var KeypadAreaAssigmentsRequest = /** @class */ (function (_super) {
    __extends$1(KeypadAreaAssigmentsRequest, _super);
    function KeypadAreaAssigmentsRequest() {
        return _super.call(this, 'k', 'a') || this;
    }
    return KeypadAreaAssigmentsRequest;
}(ElkCommand));

/**
 * Request Keypad Function Key Press
 *
 * This command simulates a function key being pressed on a keypad.
 * This will only be single key press even if the M1 Control is
 * programmed for double function key press. M1 Version 4.2.5 and
 * after.
 *
 * SilenceTroubleBeep (‘*’) key: M1 Version 4.2.6 and after
 * Chime (‘C’) key: M1 Version 4.3.2 and after.
 *
 * @see 4.22.1 Request Keypad Function Key Press (kf)
 */
var KeypadFunctionKeyPressRequest = /** @class */ (function (_super) {
    __extends$1(KeypadFunctionKeyPressRequest, _super);
    function KeypadFunctionKeyPressRequest(keypadNumber, functionKey) {
        if (functionKey === void 0) { functionKey = FunctionKey$1.None; }
        var _this = _super.call(this, 'k', 'f', keypadNumber.toString().padStart(2, '0') + String.fromCharCode(functionKey)) || this;
        _this.keypadNumber = keypadNumber;
        _this.functionKey = functionKey;
        return _this;
    }
    return KeypadFunctionKeyPressRequest;
}(ElkCommand));

/**
 * Request Keypad Function Key Illumination Status
 *
 * The function key illumination request returns the Keypad KeyChange
 * Update (KC) data with the Key Number set to zero (0). This command
 * allows automation equipment to request the illumination status of
 * the keypad function keys for building virtual keypads on a PC.
 *
 * @see 4.21.1 Request Keypad Function Key Illumination Status (kc)
 */
var KeypadFunctionKeyStatusRequest = /** @class */ (function (_super) {
    __extends$1(KeypadFunctionKeyStatusRequest, _super);
    function KeypadFunctionKeyStatusRequest(keypadNumber) {
        var _this = _super.call(this, 'k', 'c', keypadNumber.toString().padStart(2, '0')) || this;
        _this.keypadNumber = keypadNumber;
        return _this;
    }
    return KeypadFunctionKeyStatusRequest;
}(ElkCommand));

/**
 * Request Lighting Device Status
 *
 * This command allows the M1 to poll single light devices to obtain
 * their on, off, dim status. This will be an automatic command issued
 * from the M1 to the M1XSP Type modules that connect to lighting devices.
 * Note: Only single light devices can be polled for status. Groups and
 * scenes will not return valid data. Enable the “2 Way” Poll setting for
 * the device to be polled. M1 Version 4.3.9 and after. This command
 * cannot be used by automation equipment.
 *
 * @see 4.14.1 Request Lighting Device Status (ds)
 */
var LightingDeviceStatusRequest = /** @class */ (function (_super) {
    __extends$1(LightingDeviceStatusRequest, _super);
    function LightingDeviceStatusRequest(lightingDeviceNumber) {
        var _this = _super.call(this, 'd', 's', lightingDeviceNumber.toString().padStart(3, '0')) || this;
        _this.lightingDeviceNumber = lightingDeviceNumber;
        return _this;
    }
    return LightingDeviceStatusRequest;
}(ElkCommand));

/**
 * Request - Omnistat 2 From PC to M1 ASCII Protocol
 *
 * This request command allows for requesting data from the M1XSP that
 * is connected to the HAI Omnistate 2 HVAC Thermostat. The Omnistat 2
 * protocol is required to build the ASCII command strings. M1 version
 * 5.1.9 or later is required for this command.
 *
 * @see 4.35.4 Request - Omnistat 2 From PC to M1 ASCII Protocol (t2)
 */
var Omnistat2Request = /** @class */ (function (_super) {
    __extends$1(Omnistat2Request, _super);
    function Omnistat2Request(omnistatData) {
        var _this = _super.call(this, 't', '2', omnistatData.padEnd(36, '0')) || this;
        _this.omnistatData = omnistatData;
        return _this;
    }
    return Omnistat2Request;
}(ElkCommand));

/**
 * Control Any PLC Device
 *
 * @see 4.25.1 Control Any PLC Device (pc)
 */
var PlcDeviceControl = /** @class */ (function (_super) {
    __extends$1(PlcDeviceControl, _super);
    function PlcDeviceControl(houseCode, unitCode, functionCode, extendedCode, onTime) {
        var _this = _super.call(this, 'p', 'c', houseCode +
            unitCode.toString().padStart(2, '0') +
            functionCode.toString().padStart(2, '0') +
            extendedCode.toString().padStart(2, '0') +
            onTime.toString().padStart(4, '0')) || this;
        _this.houseCode = houseCode;
        _this.unitCode = unitCode;
        _this.functionCode = functionCode;
        _this.extendedCode = extendedCode;
        _this.onTime = onTime;
        return _this;
    }
    return PlcDeviceControl;
}(ElkCommand));

/**
 * Turn OFF PLC Device
 *
 * @see 4.25.3 Turn OFF PLC Device (pf)
 */
var PlcDeviceOff = /** @class */ (function (_super) {
    __extends$1(PlcDeviceOff, _super);
    function PlcDeviceOff(houseCode, unitCode) {
        var _this = _super.call(this, 'p', 'f', houseCode + unitCode.toString().padStart(2, '0')) || this;
        _this.houseCode = houseCode;
        _this.unitCode = unitCode;
        return _this;
    }
    return PlcDeviceOff;
}(ElkCommand));

/**
 * Turn ON PLC Device
 *
 * @see 4.25.4 Turn ON PLC Device (pn)
 */
var PlcDeviceOn = /** @class */ (function (_super) {
    __extends$1(PlcDeviceOn, _super);
    function PlcDeviceOn(houseCode, unitCode) {
        var _this = _super.call(this, 'p', 'n', houseCode + unitCode.toString().padStart(2, '0')) || this;
        _this.houseCode = houseCode;
        _this.unitCode = unitCode;
        return _this;
    }
    return PlcDeviceOn;
}(ElkCommand));

/**
 * Request PLC status
 *
 * @see 4.25.5 Request PLC status (ps)
 */
var PlcDeviceStatusRequest = /** @class */ (function (_super) {
    __extends$1(PlcDeviceStatusRequest, _super);
    function PlcDeviceStatusRequest(bank) {
        var _this = _super.call(this, 'p', 's', bank.toString()) || this;
        _this.bank = bank;
        return _this;
    }
    return PlcDeviceStatusRequest;
}(ElkCommand));

/**
 * Toggle PLC Device
 *
 * @see 4.25.7 Toggle PLC Device (pt)
 */
var PlcDeviceToggle = /** @class */ (function (_super) {
    __extends$1(PlcDeviceToggle, _super);
    function PlcDeviceToggle(houseCode, unitCode) {
        var _this = _super.call(this, 'p', 't', houseCode + unitCode.toString().padStart(2, '0')) || this;
        _this.houseCode = houseCode;
        _this.unitCode = unitCode;
        return _this;
    }
    return PlcDeviceToggle;
}(ElkCommand));

/**
 * Request Real Time Clock Data
 *
 * @see 4.28.1 Request Real Time Clock Data (rr)
 */
var RealTimeClockDataRequest = /** @class */ (function (_super) {
    __extends$1(RealTimeClockDataRequest, _super);
    function RealTimeClockDataRequest() {
        return _super.call(this, 'r', 'r') || this;
    }
    return RealTimeClockDataRequest;
}(ElkCommand));

/**
 * Write Real Time Clock Data
 *
 * @see 4.28.3 Write Real Time Clock Data (rw)
 */
var RealTimeClockDataWrite = /** @class */ (function (_super) {
    __extends$1(RealTimeClockDataWrite, _super);
    function RealTimeClockDataWrite(year, month, day, dayOfWeek, hour, minutes, seconds) {
        var _this = _super.call(this, 'r', 'w', seconds.toString().padStart(2, '0') +
            minutes.toString().padStart(2, '0') +
            hour.toString().padStart(2, '0') +
            dayOfWeek.toString() +
            day.toString().padStart(2, '0') +
            month.toString().padStart(2, '0') +
            year
                .toString()
                .padStart(2, '0')
                .substr(-2)) || this;
        _this.year = year;
        _this.month = month;
        _this.day = day;
        _this.dayOfWeek = dayOfWeek;
        _this.hour = hour;
        _this.minutes = minutes;
        _this.seconds = seconds;
        return _this;
    }
    return RealTimeClockDataWrite;
}(ElkCommand));

/**
 * Speak Phrase at Voice/Siren Output
 *
 * @see 4.32.2 Speak Phrase at Voice/Siren Output (sp)
 */
var SpeakPhrase = /** @class */ (function (_super) {
    __extends$1(SpeakPhrase, _super);
    function SpeakPhrase(phraseNumber) {
        var _this = _super.call(this, 's', 'p', phraseNumber.toString().padStart(3, '0')) || this;
        _this.phraseNumber = phraseNumber;
        return _this;
    }
    return SpeakPhrase;
}(ElkCommand));

/**
 * Speak Word at Voice/Siren Output
 *
 * @see 4.32.1 Speak Word at Voice/Siren Output (sw)
 */
var SpeakWord = /** @class */ (function (_super) {
    __extends$1(SpeakWord, _super);
    function SpeakWord(wordNumber) {
        var _this = _super.call(this, 's', 'w', wordNumber.toString().padStart(3, '0')) || this;
        _this.wordNumber = wordNumber;
        return _this;
    }
    return SpeakWord;
}(ElkCommand));

/**
 * Request System Log Data
 *
 * Request to get system log data entry. The first entry is
 * index “1”, the last entry is index “511”. Log data index
 * “0” is the next location to be written, index 511 is
 * the oldest log data.
 *
 * @see 4.23.1 Request System Log Data (ld)
 */
var SystemLogDataReadRequest = /** @class */ (function (_super) {
    __extends$1(SystemLogDataReadRequest, _super);
    function SystemLogDataReadRequest(logIndex) {
        var _this = _super.call(this, 'l', 'd', logIndex.toString().padStart(3, '0')) || this;
        _this.logIndex = logIndex;
        return _this;
    }
    return SystemLogDataReadRequest;
}(ElkCommand));

/**
 * Request Write Log Data
 *
 * The Write Log Data Command “le” writes log data into the
 * M1 log specifically to trigger communicator reporting to
 * the central station. A valid zone must be programmed for
 * communicator reporting. The M1 will return an “OK”crlf
 * response when the data is written to the log.
 *
 * @see 4.23.2 Request Write Log Data (le)
 */
var SystemLogDataWriteRequest = /** @class */ (function (_super) {
    __extends$1(SystemLogDataWriteRequest, _super);
    function SystemLogDataWriteRequest(logType, eventType, zoneNumber, areaNumber) {
        var _this = _super.call(this, 'l', 'e', logType.toString().padStart(3, '0') +
            eventType
                .toString()
                .padStart(4, '0')
                .substr(-3) +
            zoneNumber.toString().padStart(3, '0') +
            areaNumber.toString()) || this;
        _this.logType = logType;
        _this.eventType = eventType;
        _this.zoneNumber = zoneNumber;
        _this.areaNumber = areaNumber;
        return _this;
    }
    return SystemLogDataWriteRequest;
}(ElkCommand));

/**
 * Request System Trouble Status
 *
 * This command allows automation equipment to poll for
 * system trouble status. Firmware revision 4.5.4, 5.1.4
 * and after. This message will automatically be sent
 * upon a trouble status change.
 *
 * @see 4.30.1 Request System Trouble Status (ss)
 */
var SystemTroubleStatusRequest = /** @class */ (function (_super) {
    __extends$1(SystemTroubleStatusRequest, _super);
    function SystemTroubleStatusRequest() {
        return _super.call(this, 's', 's') || this;
    }
    return SystemTroubleStatusRequest;
}(ElkCommand));

/**
 * Task Activation
 *
 * You can use your PC to send a command to activate a Task. Tasks
 * are event flags that are common to the telephone remote control
 * option 2, the keypad user menu option 1, the Whenever/Then
 * programming, and the ASCII string programming. Any one of these
 * methods can activate a Task (events 2001 to 2032). The
 * Whenever/Then programming rules can then issue control commands
 * when a Task has been activated. When all rules that are activated
 * from the Task is serviced, the Task will be de-activated.
 *
 * The data portion of the Task Activation command, DDD, is three
 * decimal ASCII digits (1 base) corresponding to the number of the
 * desired Task to activate. Range: 001 to 032. This value is a three
 * digit value for future expansion.
 *
 * @see 4.34 Task Activation (tn)
 */
var TaskActivation = /** @class */ (function (_super) {
    __extends$1(TaskActivation, _super);
    function TaskActivation(taskNumber) {
        var _this = _super.call(this, 't', 'n', taskNumber.toString().padStart(3, '0')) || this;
        _this.taskNumber = taskNumber;
        return _this;
    }
    return TaskActivation;
}(ElkCommand));

/**
 * Request Temperature Data
 *
 * This command allows automation equipment to request
 * the temperatures from zone temperature sensors and
 * keypad temperatures in one ASCII packet.
 * M1 Version 4.3.4 andafter.
 *
 * @see 4.24.1 Request Temperature Data (lw)
 */
var TemperatureDataRequest = /** @class */ (function (_super) {
    __extends$1(TemperatureDataRequest, _super);
    function TemperatureDataRequest() {
        return _super.call(this, 'l', 'w') || this;
    }
    return TemperatureDataRequest;
}(ElkCommand));

/**
 * Request Temperature format
 *
 * This request command allows automation equipment to read
 * temperatures of the temperature probes connected to zones
 * 1 to 16, Keypad temperature from the sensor in each LCD
 * keypad, and Thermostat temperatures. Each Group can have
 * up to 16 temperature sensors.
 *
 * Version 4.2.8 and later sends automatic temperature updates
 * out Port 0 when any temperature device parameter changes.
 *
 * @see 4.31.1 Request Temperature format (st)
 */
var TemperatureRequest = /** @class */ (function (_super) {
    __extends$1(TemperatureRequest, _super);
    function TemperatureRequest(deviceType, deviceNumber) {
        var _this = _super.call(this, 's', 't', deviceType.toString() + deviceNumber.toString().padStart(2, '0')) || this;
        _this.deviceType = deviceType;
        _this.deviceNumber = deviceNumber;
        return _this;
    }
    return TemperatureRequest;
}(ElkCommand));

/**
 * Request ASCII String Text Descriptions
 *
 * This request command allows automation equipment to read
 * the text descriptions that are stored in the control.
 *
 * The control will response with a {@link TextDescriptionResponse}.
 *
 * NOTE! The {@link TextDescriptionResponse} may not be for the
 * `address` requested! If there is no description for the requested
 * address the next addresses will be searched until one with a
 * description is found (or, if none are found, an address of `0` will
 * be returned).
 *
 * From the protocol specification:
 * > If the first character in a requested name is a “space” or less,
 * > then the next names are searched until a name is found whose first
 * > character is greater than “space” or the “Show On Keypad” bit is
 * > set. If no valid names are found, a “000” for the NNN address is
 * > returned. This speeds up the loading of names so that invalid
 * > names are not returned. M1 version 2.4.6 or later.
 *
 * @see 4.29.1 Request ASCII String Text Descriptions (sd)
 */
var TextDescriptionRequest = /** @class */ (function (_super) {
    __extends$1(TextDescriptionRequest, _super);
    function TextDescriptionRequest(textType, address) {
        var _this = _super.call(this, 's', 'd', textType.toString().padStart(2, '0') + address.toString().padStart(3, '0')) || this;
        _this.textType = textType;
        _this.address = address;
        return _this;
    }
    return TextDescriptionRequest;
}(ElkCommand));

/**
 * Request Thermostat Data
 *
 * This command allows automation equipment to monitor and control
 * HVAC Thermostats connected to the M1. All temperature settings
 * are expressed in ASCII Decimal, two digits. M1 Version 4.2.6 and after.
 *
 * @see 4.35.1 Request Thermostat Data (tr)
 */
var ThermostatDataRequest = /** @class */ (function (_super) {
    __extends$1(ThermostatDataRequest, _super);
    function ThermostatDataRequest(thermostatNumber) {
        var _this = _super.call(this, 't', 'r', thermostatNumber.toString().padStart(2, '0')) || this;
        _this.thermostatNumber = thermostatNumber;
        return _this;
    }
    return ThermostatDataRequest;
}(ElkCommand));

/**
 * Set Thermostat Data
 *
 * @see 4.35.3 Set Thermostat Data (ts)
 */
var ThermostatSet = /** @class */ (function (_super) {
    __extends$1(ThermostatSet, _super);
    function ThermostatSet(thermostatNumber, value, element) {
        var _this = _super.call(this, 't', 's', thermostatNumber.toString().padStart(2, '0') +
            value.toString().padStart(2, '0') +
            element.toString()) || this;
        _this.thermostatNumber = thermostatNumber;
        _this.value = value;
        _this.element = element;
        return _this;
    }
    return ThermostatSet;
}(ElkCommand));

/**
 * Set Thermostat Data
 *
 * @see 4.35.3 Set Thermostat Data (ts)
 */
var ThermostatSetCoolSetPoint = /** @class */ (function (_super) {
    __extends$1(ThermostatSetCoolSetPoint, _super);
    function ThermostatSetCoolSetPoint(thermostatNumber, temperature) {
        var _this = _super.call(this, thermostatNumber, temperature, ThermostatSetType$1.CoolSetPoint) || this;
        _this.temperature = temperature;
        return _this;
    }
    return ThermostatSetCoolSetPoint;
}(ThermostatSet));

/**
 * Set Thermostat Data
 *
 * @see 4.35.3 Set Thermostat Data (ts)
 */
var ThermostatSetFan = /** @class */ (function (_super) {
    __extends$1(ThermostatSetFan, _super);
    function ThermostatSetFan(thermostatNumber, isOn) {
        var _this = _super.call(this, thermostatNumber, isOn ? 1 : 0, ThermostatSetType$1.Fan) || this;
        _this.isOn = isOn;
        return _this;
    }
    return ThermostatSetFan;
}(ThermostatSet));

/**
 * Set Thermostat Data
 *
 * @see 4.35.3 Set Thermostat Data (ts)
 */
var ThermostatSetHeatSetPoint = /** @class */ (function (_super) {
    __extends$1(ThermostatSetHeatSetPoint, _super);
    function ThermostatSetHeatSetPoint(thermostatNumber, temperature) {
        var _this = _super.call(this, thermostatNumber, temperature, ThermostatSetType$1.HeatSetPoint) || this;
        _this.temperature = temperature;
        return _this;
    }
    return ThermostatSetHeatSetPoint;
}(ThermostatSet));

/**
 * Set Thermostat Data
 *
 * @see 4.35.3 Set Thermostat Data (ts)
 */
var ThermostatSetHold = /** @class */ (function (_super) {
    __extends$1(ThermostatSetHold, _super);
    function ThermostatSetHold(thermostatNumber, isOn) {
        var _this = _super.call(this, thermostatNumber, isOn ? 1 : 0, ThermostatSetType$1.Hold) || this;
        _this.isOn = isOn;
        return _this;
    }
    return ThermostatSetHold;
}(ThermostatSet));

/**
 * Set Thermostat Data
 *
 * @see 4.35.3 Set Thermostat Data (ts)
 */
var ThermostatSetMode = /** @class */ (function (_super) {
    __extends$1(ThermostatSetMode, _super);
    function ThermostatSetMode(thermostatNumber, mode) {
        var _this = _super.call(this, thermostatNumber, mode - 48, ThermostatSetType$1.Mode) || this;
        _this.mode = mode;
        return _this;
    }
    return ThermostatSetMode;
}(ThermostatSet));

/**
 * Request Valid User Code Areas
 *
 * This request command allows automation equipment to send a
 * user code to the control and have returned what areas the
 * code is valid in. The returned value is an 8 bit masked value
 * with bit 0 corresponding to area 1, up to bit 7 corresponding
 * to area 8. If the returned value is 0, then the code is not valid
 * in any area. M1 Version 4.2.5 , type of code is in Version 4.3.6
 * and after.
 *
 * @see 4.37.1 Request Valid User Code Areas (ua)
 */
var UserCodeAreasRequest = /** @class */ (function (_super) {
    __extends$1(UserCodeAreasRequest, _super);
    function UserCodeAreasRequest(userCode) {
        var _this = _super.call(this, 'u', 'a', userCode.padStart(6, '0')) || this;
        _this.userCode = userCode;
        return _this;
    }
    return UserCodeAreasRequest;
}(ElkCommand));

/**
 * Encodes selected area numbers.
 *
 * Two ASCII Hex characters, 0-9,A-F, using the Hex value of each
 * character as the mask for 4 areas. Right most character is
 * areas 1 to 4 with bit 0 equal to Area 1.
 *
 * @param areaNumbers An array of area numbers to encode
 * @return {string} The area numbers encoded as hex.
 */
function encodeAreaNumbers(areaNumbers) {
    if (!areaNumbers || !areaNumbers.length) {
        return '00';
    }
    // Start with an array of all 0s, replacing any area numbers with 1's.
    var bitValues = areaNumbers
        .reduce(function (bits, areaNumber) {
        return bits
            .slice(0, areaNumber - 1)
            .concat(1)
            .concat(bits.slice(areaNumber));
    }, [0, 0, 0, 0, 0, 0, 0, 0])
        .reverse(); // reverse: bit 0 = area 1, etc.
    // Join them as a single string and parse them as a binary number,
    // then convert them to a 2-character hex string.
    return parseInt(bitValues.join(''), 2)
        .toString(16)
        .padStart(2, '0')
        .toUpperCase();
}
function generateData(userNumber, masterOrCurrentUserCode, newUserCode, areaNumbers) {
    var authCode = typeof masterOrCurrentUserCode === 'string'
        ? new UserCode(masterOrCurrentUserCode)
        : masterOrCurrentUserCode;
    var newCode = typeof newUserCode === 'string' ? new UserCode(newUserCode) : newUserCode;
    return (userNumber.toString().padStart(3, '0') +
        authCode.encode() +
        newCode.encode() +
        encodeAreaNumbers(areaNumbers));
}
/**
 * Request Change User Code
 *
 * This command allows automation equipment to change a user code. The
 * data packet must include a Master User Code or the current user code
 * of the user code to be changed. 4.3.9 and after.
 *
 * @see 4.11.1 Request Change User Code (cu)
 */
var UserCodeChangeRequest = /** @class */ (function (_super) {
    __extends$1(UserCodeChangeRequest, _super);
    function UserCodeChangeRequest(userNumber, masterOrCurrentUserCode, newUserCode, areaNumbers, changeType) {
        if (changeType === void 0) { changeType = UserCodeChangeType$1.UserCode; }
        var _this = _super.call(this, 'c', 'u', generateData(userNumber, masterOrCurrentUserCode, newUserCode, areaNumbers)) || this;
        _this.userNumber = userNumber;
        _this.areaNumbers = areaNumbers;
        _this.changeType = changeType;
        _this.authorizationUserCode =
            typeof masterOrCurrentUserCode === 'string'
                ? new UserCode(masterOrCurrentUserCode)
                : masterOrCurrentUserCode;
        _this.newUserCode = typeof newUserCode === 'string' ? new UserCode(newUserCode) : newUserCode;
        return _this;
    }
    Object.defineProperty(UserCodeChangeRequest.prototype, "reserved", {
        get: function () {
            return this.changeType.toString() + '0';
        },
        enumerable: true,
        configurable: true
    });
    return UserCodeChangeRequest;
}(ElkCommand));

/**
 * Request M1 Version Number
 *
 * The vn command requests the M1’s version number,
 * and the VN command replies with the version number
 * data. If an M1XEP is connected to the M1, the M1XEP’s
 * version number will also be included. Available in M1
 * version 4.1.12 or 5.1.12 and later. M1XEP 1.3.2 or later.
 *
 * @see 4.36.1 Request M1 Version Number (vn)
 */
var VersionNumberRequest = /** @class */ (function (_super) {
    __extends$1(VersionNumberRequest, _super);
    function VersionNumberRequest() {
        return _super.call(this, 'v', 'n') || this;
    }
    return VersionNumberRequest;
}(ElkCommand));

/**
 * Zone Bypass Request
 *
 * This command allows for bypassing/unbypassing a zone.
 * Zone = 000 will unbypass all burglar zones in the.
 * Zone = 999 will bypass all violated burglar zones.
 * Area to bypass/unbypass is required if Zone equals
 * 000 or 999 otherwise it is ignored.
 *
 * @see 4.40.1 Zone Bypass Request (zb)
 */
var ZoneBypassRequest = /** @class */ (function (_super) {
    __extends$1(ZoneBypassRequest, _super);
    function ZoneBypassRequest(pinCode, zoneNumber, areaNumber) {
        if (areaNumber === void 0) { areaNumber = 0; }
        var _this = _super.call(this, 'z', 'b', zoneNumber.toString().padStart(3, '0') + areaNumber.toString() + pinCode.padStart(6, '0')) || this;
        _this.pinCode = pinCode;
        _this.zoneNumber = zoneNumber;
        _this.areaNumber = areaNumber;
        return _this;
    }
    return ZoneBypassRequest;
}(ElkCommand));

/**
 * Request Zone Definition
 *
 * This command allows automation equipment to request the
 * zone definitions. 4.2.6 and after.
 *
 * @see 4.41.1 Request Zone Definition (zd)
 */
var ZoneDefinitionRequest = /** @class */ (function (_super) {
    __extends$1(ZoneDefinitionRequest, _super);
    function ZoneDefinitionRequest() {
        return _super.call(this, 'z', 'd') || this;
    }
    return ZoneDefinitionRequest;
}(ElkCommand));

/**
 * Zone Partition Request
 *
 * The Control panel responds with a {@link ZonePartitionReport}
 * which tells what Area is assigned to each zone.
 *
 * @see 4.40.3 Zone Partition Request (zp)
 */
var ZonePartitionRequest = /** @class */ (function (_super) {
    __extends$1(ZonePartitionRequest, _super);
    function ZonePartitionRequest() {
        return _super.call(this, 'z', 'p') || this;
    }
    return ZonePartitionRequest;
}(ElkCommand));

/**
 * Zone Status Request
 *
 * The control panel responds with a {@link ZoneStatusReport}.
 *
 * Note: This message should be sent only when an initial
 * connection is made with the control panel. It is not
 * intended to be used as a ‘polling’ command. The control
 * panel can be programmed to send zone and system status
 * messages whenever the status changes with Global Programming
 * Location 33 – 37 in the M1 Control.
 *
 * @see 4.40.5 Zone Status Request (zs)
 */
var ZoneStatusRequest = /** @class */ (function (_super) {
    __extends$1(ZoneStatusRequest, _super);
    function ZoneStatusRequest() {
        return _super.call(this, 'z', 's') || this;
    }
    return ZoneStatusRequest;
}(ElkCommand));

/**
 * Zone Trigger
 *
 * This command allows a 3rd party integration device to trigger
 * an alarm condition on a EOL hardwired zone defined with any
 * of the Burglary zone types and many other zone types up to
 * zone type 26. This command creates a virtual momentary open
 * condition on the zone as if the EOL hardwired loop had been
 * physically opened. This requires M1 Version 4.5.23, 5.1.23
 * or later. Caution: This command cannot create a virtual short
 * condition and therefore cannot trigger an alarm condition for
 * zone types that require a short. i.e. Fire zone alarms cannot
 * be triggered.
 *
 * @see 4.42.1 Zone Trigger (zt)
 */
var ZoneTrigger = /** @class */ (function (_super) {
    __extends$1(ZoneTrigger, _super);
    function ZoneTrigger(zoneNumber) {
        var _this = _super.call(this, 'z', 't', zoneNumber.toString().padStart(3, '0')) || this;
        _this.zoneNumber = zoneNumber;
        return _this;
    }
    return ZoneTrigger;
}(ElkCommand));

/**
 * Request Zone Voltage
 *
 * This command allows automation equipment to request a
 * zone analog voltage level. M1 Version 4.2.8 and after.
 *
 * @see 4.43.1 Request Zone Voltage (zv)
 */
var ZoneVoltageRequest = /** @class */ (function (_super) {
    __extends$1(ZoneVoltageRequest, _super);
    function ZoneVoltageRequest(zoneNumber) {
        var _this = _super.call(this, 'z', 'v', zoneNumber.toString().padStart(3, '0')) || this;
        _this.zoneNumber = zoneNumber;
        return _this;
    }
    return ZoneVoltageRequest;
}(ElkCommand));

/**
 * Represents the current state of a connection to the Elk M1
 */
var ElkConnectionState;
(function (ElkConnectionState) {
    /**
     * The connection is not connected.
     */
    ElkConnectionState[ElkConnectionState["Disconnected"] = 0] = "Disconnected";
    /**
     * In the process of connecting.
     */
    ElkConnectionState[ElkConnectionState["Connecting"] = 1] = "Connecting";
    /**
     * Successfully connected.
     */
    ElkConnectionState[ElkConnectionState["Connected"] = 2] = "Connected";
    /**
     * The connection is still alive but in the process of disconnecting
     * (one side has issued a disconnection notice, but the other side may
     * node have responded yet.)
     */
    ElkConnectionState[ElkConnectionState["Disconnecting"] = 3] = "Disconnecting";
})(ElkConnectionState || (ElkConnectionState = {}));
var ElkConnectionState$1 = ElkConnectionState;

var TimeoutError = /** @class */ (function (_super) {
    __extends(TimeoutError, _super);
    function TimeoutError(timeoutMs, message) {
        var _this = _super.call(this, message) || this;
        _this.timeoutMs = timeoutMs;
        Object.setPrototypeOf(_this, TimeoutError.prototype);
        return _this;
    }
    return TimeoutError;
}(Error));

/**
 * Wraps a promise in a new promise that will reject if the promise is not
 * resolved or rejected within the timeout provided.
 */
function withTimeout(timeoutMs, promise) {
    if (timeoutMs < 1) {
        return promise;
    }
    return new Promise(function (resolve, reject) {
        var timeout = setTimeout(function () { return reject(new TimeoutError(timeoutMs)); }, timeoutMs);
        promise
            .then(function (result) {
            clearTimeout(timeout);
            resolve(result);
        })
            .catch(function (error) {
            clearTimeout(timeout);
            reject(error);
        });
    });
}

/**
 * An abstract client implementation of sending/receiving specific
 * messages from the Elk M1.
 *
 * This is just a way to declutter the client and separate out the
 * specific command implementations.
 */
var ElkClientCommands = /** @class */ (function (_super) {
    __extends(ElkClientCommands, _super);
    function ElkClientCommands() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Waits for a response that matches the predicate provided and resolves when it
     * is found, or rejects if it is not found within the timeframe.
     */
    ElkClientCommands.prototype.waitForResponse = function (predicate, timeoutMs) {
        if (timeoutMs === void 0) { timeoutMs = this.defaultTimeout; }
        return __awaiter(this, void 0, void 0, function () {
            var messageListener;
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, withTimeout(timeoutMs, new Promise(function (resolve) {
                        messageListener = function (responseToCheck) {
                            if (predicate(responseToCheck)) {
                                resolve(responseToCheck);
                            }
                        };
                        _this.on('message', messageListener);
                    }))
                        .catch(function (error) {
                        _this.removeListener('message', messageListener);
                        throw error;
                    })
                        .then(function (result) {
                        _this.removeListener('message', messageListener);
                        return result;
                    })];
            });
        });
    };
    /**
     * Waits for an "OK" response and resolves when it is found, or rejects if it is not found within the
     * timeout time.
     */
    ElkClientCommands.prototype.waitForOk = function (timeoutMs) {
        if (timeoutMs === void 0) { timeoutMs = this.defaultTimeout; }
        return __awaiter(this, void 0, void 0, function () {
            var okListener;
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, withTimeout(timeoutMs, new Promise(function (resolve) {
                        okListener = function () { return resolve(); };
                        _this.on('ok', okListener);
                    }))
                        .catch(function (error) {
                        _this.removeListener('ok', okListener);
                        throw error;
                    })
                        .then(function (result) {
                        _this.removeListener('ok', okListener);
                        return result;
                    })];
            });
        });
    };
    /**
     * Sends a command and waits for a {@link ElkResponse}
     * @param command The command to send
     * @param predicate A predicate function that is called for *every* response that
     *   is recevied and should return true when a response matches an expected
     *   response to the command that was sent.
     * @param timeout How long to wait for the response before rejecting.
     */
    ElkClientCommands.prototype.sendCommandForResponse = function (command, predicate, timeoutMs) {
        if (timeoutMs === void 0) { timeoutMs = this.defaultTimeout; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                // We want the timeout to apply to the entire operation, so the whole promise
                // chain gets wrapped in a `withTimeout` and `waitForResponse` is told not to timeout.
                // Otherwise we'd have to determine how much of our timeout we have left to wait
                // for the response after we sent the command.
                return [2 /*return*/, withTimeout(timeoutMs, this.sendCommand(command, timeoutMs).then(function () { return _this.waitForResponse(predicate, 0); }))];
            });
        });
    };
    /**
     * Helper method for sending a command and waiting for an "OK" response.
     */
    ElkClientCommands.prototype.sendCommandForOk = function (command, timeoutMs) {
        if (timeoutMs === void 0) { timeoutMs = this.defaultTimeout; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                // Same as above:
                // We want the timeout to apply to the entire operation, so the whole promise
                // chain gets wrapped in a `withTimeout` and `waitForResponse` is told not to timeout.
                // Otherwise we'd have to determine how much of our timeout we have left to wait
                // for the response after we sent the command.
                return [2 /*return*/, withTimeout(timeoutMs, this.sendCommand(command, timeoutMs).then(function () { return _this.waitForOk(0); }))];
            });
        });
    };
    /**
     * Helper method for sending a command and waiting for a response that matches the
     * type of response class given.
     *
     * Useful for commands that only need to check the type of response message, and not
     * any of it's underlying data.
     */
    ElkClientCommands.prototype.sendCommandForResponseType = function (command, ResponseClass) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(command, function (message) { return message instanceof ResponseClass; })];
            });
        });
    };
    ElkClientCommands.prototype.arm = function (areaNumber, armingLevel, userCode) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommand(new Arm(armingLevel, areaNumber, userCode), this.defaultTimeout)];
            });
        });
    };
    ElkClientCommands.prototype.disarm = function (areaNumber, userCode) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.arm(areaNumber, ArmingLevel$1.Disarm, userCode)];
            });
        });
    };
    ElkClientCommands.prototype.getArmingStatus = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponseType(new ArmingStatusRequest(), ArmingStatusReport)];
            });
        });
    };
    ElkClientCommands.prototype.getAlarmsByZone = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponseType(new AlarmByZoneRequest(), AlarmByZoneReport)];
            });
        });
    };
    ElkClientCommands.prototype.getAudioData = function (zoneNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new AudioDataRequest(zoneNumber), function (message) { return message instanceof AudioDataReply && message.zone === zoneNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.setControlOutputOff = function (outputNUmber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommand(new ControlOutputOff(outputNUmber), this.defaultTimeout)];
            });
        });
    };
    ElkClientCommands.prototype.setControlOutputOn = function (outputNUmber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommand(new ControlOutputOn(outputNUmber), this.defaultTimeout)];
            });
        });
    };
    ElkClientCommands.prototype.toggleControlOutput = function (outputNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommand(new ControlOutputToggle(outputNumber), this.defaultTimeout)];
            });
        });
    };
    ElkClientCommands.prototype.getControlOutputStatus = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponseType(new ControlOutputStatusRequest(), ControlOutputStatusReport)];
            });
        });
    };
    ElkClientCommands.prototype.getCustomValue = function (valueNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new CustomValueRead(valueNumber), function (message) { return message instanceof CustomValueReply && message.valueNumber === valueNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.getCustomValues = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new CustomValuesReadAll(), function (message) { return message instanceof CustomValueReply && message.valueNumber === 0; })];
            });
        });
    };
    ElkClientCommands.prototype.setCustomValue = function (valueNumber, value) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new CustomValueWrite(valueNumber, value), function (message) { return message instanceof CustomValueReply && message.valueNumber === valueNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.changeUserCode = function (userNumber, masterOrCurrentUserCode, newUserCode, areaNumbers, changeType) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new UserCodeChangeRequest(userNumber, masterOrCurrentUserCode, newUserCode, areaNumbers, changeType), function (message) { return message instanceof UserCodeChangeReply && message.userCode === userNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.getCounterValue = function (counterNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new CounterValueRead(counterNumber), function (message) { return message instanceof CounterValueReply && message.counterNumber === counterNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.setCounterValue = function (counterNumber, value) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new CounterValueWrite(counterNumber, value), function (message) { return message instanceof CounterValueReply && message.counterNumber === counterNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.displayTextOnScreen = function (areaNumber, firstLine, secondLine, clearOption, beep, timeout) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommand(new DisplayTextOnScreen(areaNumber, firstLine, secondLine, clearOption, beep, timeout), this.defaultTimeout)];
            });
        });
    };
    ElkClientCommands.prototype.clearTextOnScreen = function (areaNumber, beep) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.displayTextOnScreen(areaNumber, null, null, DisplayTextClearOption$1.Clear, beep)];
            });
        });
    };
    ElkClientCommands.prototype.getLightingDeviceStatus = function (lightingDeviceNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new LightingDeviceStatusRequest(lightingDeviceNumber), function (message) {
                        return message instanceof LightingDeviceDataReply &&
                            message.lightingDeviceNumber === lightingDeviceNumber;
                    })];
            });
        });
    };
    ElkClientCommands.prototype.getInsteonLightingDeviceStatus = function (startingDeviceNumber, deviceCount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new InsteonLightingDeviceStatusRequest(startingDeviceNumber, deviceCount), function (message) {
                        return message instanceof InsteonLightingDeviceStatusReply &&
                            message.startingDeviceNumber === startingDeviceNumber &&
                            message.deviceCount === deviceCount;
                    })];
            });
        });
    };
    ElkClientCommands.prototype.setInsteaonLightingDevice = function (startingDeviceNumber, deviceIds) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new InsteonLightingDeviceProgramRequest(startingDeviceNumber, deviceIds), function (message) {
                        return message instanceof InsteonLightingDeviceProgrammed &&
                            message.startingDeviceNumber === startingDeviceNumber &&
                            message.deviceCount === deviceIds.length;
                    })];
            });
        });
    };
    ElkClientCommands.prototype.getKeypadAreaAssignments = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponseType(new KeypadAreaAssigmentsRequest(), KeypadAreaAssignments)];
            });
        });
    };
    ElkClientCommands.prototype.getKeypadFunctionKeyStatus = function (keypadNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new KeypadFunctionKeyStatusRequest(keypadNumber), function (message) { return message instanceof KeypadKeyChange && message.keypadNumber === keypadNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.pressKeypadFunctionKey = function (keypadNumber, functionKey) {
        if (functionKey === void 0) { functionKey = FunctionKey$1.None; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new KeypadFunctionKeyPressRequest(keypadNumber, functionKey), function (message) {
                        return message instanceof KeypadFunctionKeyPressReply &&
                            message.keypadNumber === keypadNumber &&
                            message.functionKey === functionKey;
                    })];
            });
        });
    };
    ElkClientCommands.prototype.getSystemLogData = function (logIndex) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new SystemLogDataReadRequest(logIndex), function (message) { return message instanceof SystemLogDataUpdate && message.logIndex === logIndex; })];
            });
        });
    };
    ElkClientCommands.prototype.writeSystemLogData = function (logType, eventType, zoneNumber, areaNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForOk(new SystemLogDataWriteRequest(logType, eventType, zoneNumber, areaNumber))];
            });
        });
    };
    ElkClientCommands.prototype.getTemperatureData = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponseType(new TemperatureDataRequest(), TemperatureData)];
            });
        });
    };
    ElkClientCommands.prototype.setPlcDevice = function (houseCode, unitCode, functionCode, extendedCode, onTime) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommand(new PlcDeviceControl(houseCode, unitCode, functionCode, extendedCode, onTime), this.defaultTimeout)];
            });
        });
    };
    ElkClientCommands.prototype.setPlcDeviceOff = function (houseCode, unitCode) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommand(new PlcDeviceOff(houseCode, unitCode), this.defaultTimeout)];
            });
        });
    };
    ElkClientCommands.prototype.setPlcDeviceOn = function (houseCode, unitCode) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommand(new PlcDeviceOn(houseCode, unitCode), this.defaultTimeout)];
            });
        });
    };
    ElkClientCommands.prototype.togglePlcDevice = function (houseCode, unitCode) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommand(new PlcDeviceToggle(houseCode, unitCode), this.defaultTimeout)];
            });
        });
    };
    ElkClientCommands.prototype.getPlcStatus = function (bank) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new PlcDeviceStatusRequest(bank), function (message) { return message instanceof PlcDeviceStatusReply && message.bank === bank; })];
            });
        });
    };
    ElkClientCommands.prototype.getRealTimeClock = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponseType(new RealTimeClockDataRequest(), RealTimeClockDataReply)];
            });
        });
    };
    ElkClientCommands.prototype.setRealTimeClock = function (year, month, day, dayOfWeek, hour, minutes, seconds) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponseType(new RealTimeClockDataWrite(year, month, day, dayOfWeek, hour, minutes, seconds), RealTimeClockDataReply)];
            });
        });
    };
    ElkClientCommands.prototype.getDescription = function (textType, address) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // The TextDescriptionType request will not always return the address requested:
                // > If the first character in a requested name is a “space” or less, then the
                // > next names are searched until a name is found whose first character is
                // > greater than “space” or the “Show On Keypad” bit is set.
                // So we just wait for ANY `TextDescriptionReply` response. This is not ideal
                // but I'm not sure what the alternative is.
                return [2 /*return*/, this.sendCommandForResponseType(new TextDescriptionRequest(textType, address), TextDescriptionReply)];
            });
        });
    };
    ElkClientCommands.prototype.getTroubleStatus = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponseType(new SystemTroubleStatusRequest(), SystemTroubleStatusReply)];
            });
        });
    };
    ElkClientCommands.prototype.getTemperature = function (deviceType, deviceNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new TemperatureRequest(deviceType, deviceNumber), function (message) {
                        return message instanceof TemperatureReply &&
                            message.deviceType === deviceType &&
                            message.deviceNumber === deviceNumber;
                    })];
            });
        });
    };
    ElkClientCommands.prototype.speakWord = function (wordNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommand(new SpeakWord(wordNumber), this.defaultTimeout)];
            });
        });
    };
    ElkClientCommands.prototype.speakPhrase = function (phraseNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommand(new SpeakPhrase(phraseNumber), this.defaultTimeout)];
            });
        });
    };
    ElkClientCommands.prototype.activateTask = function (taskNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommand(new TaskActivation(taskNumber), this.defaultTimeout)];
            });
        });
    };
    ElkClientCommands.prototype.getThermostatData = function (thermostatNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new ThermostatDataRequest(thermostatNumber), function (message) { return message instanceof ThermostatData && message.thermostatNumber === thermostatNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.setThermostat = function (thermostatNumber, value, element) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new ThermostatSet(thermostatNumber, value, element), function (message) { return message instanceof ThermostatData && message.thermostatNumber === thermostatNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.setThermostatCoolSetPoint = function (thermostatNumber, temperature) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new ThermostatSetCoolSetPoint(thermostatNumber, temperature), function (message) { return message instanceof ThermostatData && message.thermostatNumber === thermostatNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.setThermostatHeatSetPoint = function (thermostatNumber, temperature) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new ThermostatSetHeatSetPoint(thermostatNumber, temperature), function (message) { return message instanceof ThermostatData && message.thermostatNumber === thermostatNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.setThermostatFan = function (thermostatNumber, on) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new ThermostatSetFan(thermostatNumber, on), function (message) { return message instanceof ThermostatData && message.thermostatNumber === thermostatNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.setThermostatMode = function (thermostatNumber, mode) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new ThermostatSetMode(thermostatNumber, mode), function (message) { return message instanceof ThermostatData && message.thermostatNumber === thermostatNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.setThermostatHold = function (thermostatNumber, on) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new ThermostatSetHold(thermostatNumber, on), function (message) { return message instanceof ThermostatData && message.thermostatNumber === thermostatNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.getOmnistat2Data = function (onmistatData) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponseType(new Omnistat2Request(onmistatData), Omnistat2Reply)];
            });
        });
    };
    ElkClientCommands.prototype.getVersionNumber = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponseType(new VersionNumberRequest(), VersionNumberReply)];
            });
        });
    };
    ElkClientCommands.prototype.getValidUserCodeAreas = function (userCode) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new UserCodeAreasRequest(userCode), function (message) {
                        return message instanceof UserCodeAreasReply && message.userCode === userCode.padStart(6, '0');
                    })];
            });
        });
    };
    ElkClientCommands.prototype.toggleBypassForZone = function (pinCode, zoneNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new ZoneBypassRequest(pinCode, zoneNumber), function (message) { return message instanceof ZoneBypassReply && message.zoneNumber === zoneNumber; })];
            });
        });
    };
    ElkClientCommands.prototype.toggleBypassForArea = function (pinCode, areaNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new ZoneBypassRequest(pinCode, 0, areaNumber), function (message) { return message instanceof ZoneBypassReply && message.zoneNumber === 0; })];
            });
        });
    };
    ElkClientCommands.prototype.getZonePartitions = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponseType(new ZonePartitionRequest(), ZonePartitionReport)];
            });
        });
    };
    ElkClientCommands.prototype.getZoneStatus = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponseType(new ZoneStatusRequest(), ZoneStatusReport)];
            });
        });
    };
    ElkClientCommands.prototype.getZoneDefinitions = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponseType(new ZoneDefinitionRequest(), ZoneDefinitionData)];
            });
        });
    };
    ElkClientCommands.prototype.triggerZone = function (zoneNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommand(new ZoneTrigger(zoneNumber), this.defaultTimeout)];
            });
        });
    };
    ElkClientCommands.prototype.getZoneVoltage = function (zoneNumber) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.sendCommandForResponse(new ZoneVoltageRequest(zoneNumber), function (message) { return message instanceof ZoneVoltageData && message.zoneNumber === zoneNumber; })];
            });
        });
    };
    return ElkClientCommands;
}(EventEmitter));

var ElkClientState;
(function (ElkClientState) {
    /**
     * The client is disconnected.
     */
    ElkClientState[ElkClientState["Disconnected"] = 0] = "Disconnected";
    /**
     * The client is in the process of disconnecting.
     */
    ElkClientState[ElkClientState["Disconnecting"] = 1] = "Disconnecting";
    /**
     * The client is in the process of connecting.
     */
    ElkClientState[ElkClientState["Connecting"] = 2] = "Connecting";
    /**
     * The client is connected and in the process of authenticating.
     */
    ElkClientState[ElkClientState["Authenticating"] = 3] = "Authenticating";
    /**
     * The client has connected and is ready to issue commands and
     * receive responses.
     */
    ElkClientState[ElkClientState["Ready"] = 100] = "Ready";
})(ElkClientState || (ElkClientState = {}));
var ElkClientState$1 = ElkClientState;

var AuthenticationFailedReason;
(function (AuthenticationFailedReason) {
    AuthenticationFailedReason[AuthenticationFailedReason["Unknown"] = 0] = "Unknown";
    AuthenticationFailedReason[AuthenticationFailedReason["InvalidCredentials"] = 1] = "InvalidCredentials";
    AuthenticationFailedReason[AuthenticationFailedReason["MissingUsername"] = 2] = "MissingUsername";
    AuthenticationFailedReason[AuthenticationFailedReason["MissingPassword"] = 3] = "MissingPassword";
})(AuthenticationFailedReason || (AuthenticationFailedReason = {}));
/**
 * Inidicates that an authentication error occured. Either
 * authentication failed, or there was no authentication
 * information provided.
 */
var AuthenticationFailedError = /** @class */ (function (_super) {
    __extends(AuthenticationFailedError, _super);
    function AuthenticationFailedError(reason, message) {
        if (reason === void 0) { reason = AuthenticationFailedReason.Unknown; }
        var _this = _super.call(this, message) || this;
        _this.reason = reason;
        Object.setPrototypeOf(_this, AuthenticationFailedError.prototype);
        return _this;
    }
    return AuthenticationFailedError;
}(Error));

function createSecureSocket(options) {
    return connect(options.port, options.host, __assign({ rejectUnauthorized: false, secureProtocol: 'TLSv1_method' }, options.secureOptions));
}

function createSocket(_a) {
    var host = _a.host, port = _a.port;
    return connect$1(port, host);
}

function createSocket$1(options) {
    var socket = options.secure ? createSecureSocket(options) : createSocket(options);
    socket.setEncoding('ascii');
    socket.setTimeout(options.idleTimeout);
    return socket;
}

/**
 * The default host name to use when one is not specified.
 *
 * 192.168.0.251 is the default IP address that the Elk M1
 * assigns to itself when it is not given one by a DHCP server
 * or when it is expicitly reset.
 */
var DEFAULT_HOST = '192.168.0.251';
/**
 * The default port to connect to when using an insecure connection.
 */
var DEFAULT_INSECURE_PORT = 2101;
/**
 * The default port to connect to when using a secure connection.
 */
var DEFAULT_SECURE_PORT = 2601;
/**
 * The default connection options to use if `secure` === false
 */
var DEFAULT_OPTIONS = {
    host: DEFAULT_HOST,
    port: DEFAULT_INSECURE_PORT,
    secure: false,
    idleTimeout: 60 * 1000,
    connectTimeout: 30 * 1000,
};
/**
 * The default connection options to use if `secure` === true
 */
var SECURE_DEFAULT_OPTIONS = __assign(__assign({}, DEFAULT_OPTIONS), { secure: true, port: DEFAULT_SECURE_PORT });

var _a$1;
/**
 * A map of connection states to the name of the event that they emit
 * when the connection is changed to that state.
 */
var STATE_CHANGE_EVENT_NAMES = (_a$1 = {},
    _a$1[ElkConnectionState$1.Disconnected] = 'disconnected',
    _a$1[ElkConnectionState$1.Connecting] = 'connecting',
    _a$1[ElkConnectionState$1.Connected] = 'connected',
    _a$1[ElkConnectionState$1.Disconnecting] = 'disconnecting',
    _a$1);

/**
 * Indicates that an {@link ElkConnection} was not in a writeable state,
 * so a command could not be successfully sent.
 */
var WriteError = /** @class */ (function (_super) {
    __extends(WriteError, _super);
    function WriteError(state, message) {
        if (message === void 0) { message = 'Connection is not writeable'; }
        var _this = _super.call(this, message) || this;
        _this.state = state;
        Object.setPrototypeOf(_this, WriteError.prototype);
        return _this;
    }
    return WriteError;
}(Error));

/**
 * An error indicating that an {@link ElkConnection} connection attempt
 * was cancelled before a connection was completely established.
 */
var ConnectCancelledError = /** @class */ (function (_super) {
    __extends(ConnectCancelledError, _super);
    function ConnectCancelledError(message) {
        if (message === void 0) { message = 'connect was cancelled.'; }
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, ConnectCancelledError.prototype);
        return _this;
    }
    return ConnectCancelledError;
}(Error));

/**
 * Idicates that an operation failed because the {@link ElkConnection}
 * was not in an expected or valid state.
 */
var NotConnectableError = /** @class */ (function (_super) {
    __extends(NotConnectableError, _super);
    /**
     *
     * @param state The state of the {@link ElkConnection}
     * @param allowedStates The states that would be expected or valid for the operation
     *   to be successful
     */
    function NotConnectableError(state, message) {
        var _this = _super.call(this, message) || this;
        _this.state = state;
        Object.setPrototypeOf(_this, NotConnectableError.prototype);
        return _this;
    }
    return NotConnectableError;
}(Error));

/**
 * A connection to an Elk M1 via a TCP socket.
 */
var ElkSocketConnection = /** @class */ (function (_super) {
    __extends(ElkSocketConnection, _super);
    function ElkSocketConnection(initialOptions) {
        if (initialOptions === void 0) { initialOptions = {}; }
        var _this = _super.call(this) || this;
        _this.initialOptions = initialOptions;
        /**
         * The most recent state of the connection.
         * Used by {@link checkForStateChange} to determine if a state change
         * event needs to be emitted.
         */
        _this._lastState = ElkConnectionState$1.Disconnected;
        /**
         * Called when the socket emits it's "connect" event.
         */
        _this.onSocketConnect = function () {
            _this.checkForStateChange();
        };
        /**
         * Called when the socket emits a "data" event.
         */
        _this.onSocketData = function (data) {
            _this.emit('data', data.toString());
        };
        /**
         * Called when the M1 closes the connection.
         */
        _this.onSocketEnd = function () {
            // Emitted when the other end of the socket sends a FIN packet,
            // thus ending the readable side of the socket.
            _this.checkForStateChange();
        };
        /**
         * Called when the socket is completely closed.
         */
        _this.onSocketClose = function ( /* hadError: boolean */) {
            // This is emitted right before a socket is destroyed.
            // Emitted once the socket is fully closed. The argument
            // hadError is a boolean which says if the socket was closed
            // due to a transmission error.
            _this.setSocket(undefined);
        };
        /**
         * Called when the underlying socket emits an error event.
         */
        _this.onSocketError = function (error) {
            // Emitted when an error occurs. The 'close' event will be called
            // directly following this event.
            if (_this._socket) {
                _this._socket.destroy(error);
            }
            _this.emit('error', error);
        };
        /**
         * Called when the underlying socket has no activity within the `idleTimeout`
         * time. This will cause the socket to be disconnected.
         */
        _this.onSocketTimeout = function () {
            // Emitted if the socket times out from inactivity.
            // This is only to notify that the socket has been idle.
            // The user must manually close the connection.
            // The user must manually call socket.end() or socket.destroy() to end the connection.
            if (_this._socket) {
                // TODO: call end and wait for a bit first before calling destroy?
                _this._socket.destroy(new TimeoutError(_this.options.idleTimeout));
            }
        };
        _this.options = __assign(__assign({}, (initialOptions.secure ? SECURE_DEFAULT_OPTIONS : DEFAULT_OPTIONS)), initialOptions);
        return _this;
    }
    Object.defineProperty(ElkSocketConnection.prototype, "state", {
        /**
         * The current state of the connection.
         */
        get: function () {
            if (this._socket) {
                if (this._socket.destroyed) {
                    return ElkConnectionState$1.Disconnected;
                }
                if (this._socket.connecting) {
                    return ElkConnectionState$1.Connecting;
                }
                if (this._socket.writable && this._socket.readable) {
                    return ElkConnectionState$1.Connected;
                }
                return ElkConnectionState$1.Disconnecting;
            }
            return ElkConnectionState$1.Disconnected;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the underlying socket being used by the connection.
     */
    ElkSocketConnection.prototype.setSocket = function (socket) {
        if (this._socket === socket) {
            // Sanity check: this really shouldn't happen.
            // If it does, there's no change so we have nothing to do.
            return;
        }
        if (this._socket) {
            // If we're replacing (or removing) an existing socket,
            // remove all of our listeners.
            this._socket.removeListener('connect', this.onSocketConnect);
            this._socket.removeListener('data', this.onSocketData);
            this._socket.removeListener('timeout', this.onSocketTimeout);
            this._socket.removeListener('error', this.onSocketError);
            this._socket.removeListener('end', this.onSocketEnd);
            this._socket.removeListener('close', this.onSocketClose);
        }
        this._socket = socket;
        // Assigning a new socket very likely changes the connection state,
        // so we may need to emit an event.
        this.checkForStateChange();
        if (this._socket) {
            // Add listeners if we've got a new socket instance.
            this._socket.on('connect', this.onSocketConnect);
            this._socket.on('data', this.onSocketData);
            this._socket.on('timeout', this.onSocketTimeout);
            this._socket.on('error', this.onSocketError);
            this._socket.on('end', this.onSocketEnd);
            this._socket.on('close', this.onSocketClose);
        }
    };
    /**
     * Checks to see if the current connection state has changed and
     * emits the appropriate event if it has.
     */
    ElkSocketConnection.prototype.checkForStateChange = function () {
        var currentState = this.state;
        if (currentState === this._lastState) {
            return;
        }
        this.emit(STATE_CHANGE_EVENT_NAMES[currentState]);
        this._lastState = currentState;
    };
    /**
     * Attempst to connect to the Elk M1
     * This should only be called when the connection is in a disconnected state,
     * otherwise it will fail with a {@link NotConnectableError}
     * @param timeout How long to wait for a connection to be established,
     *   after which the connect() call will fail.
     * @throws {NotConnectableError} if the socket is not currently disconnected.
     */
    ElkSocketConnection.prototype.connect = function (timeout) {
        if (timeout === void 0) { timeout = this.options.connectTimeout; }
        return __awaiter(this, void 0, void 0, function () {
            var connectListener, disconnectingListener, errorListener, socket;
            var _this = this;
            return __generator(this, function (_a) {
                if (this._socket) {
                    throw new NotConnectableError(this.state, 'Must be disconnected to connect.');
                }
                return [2 /*return*/, withTimeout(timeout, new Promise(function (resolve, reject) {
                        connectListener = function () { return resolve(); };
                        disconnectingListener = function () { return reject(new ConnectCancelledError()); };
                        errorListener = function (error) { return reject(error); };
                        socket = createSocket$1(_this.options);
                        socket.on('connect', connectListener);
                        _this.on('error', errorListener);
                        _this.on('disconnecting', disconnectingListener);
                        _this.setSocket(socket);
                    }))
                        .catch(function (error) {
                        socket.destroy();
                        socket.removeListener('connect', connectListener);
                        _this.removeListener('error', errorListener);
                        _this.removeListener('disconnecting', disconnectingListener);
                        _this.setSocket(undefined);
                        throw error;
                    })
                        .then(function () {
                        socket.removeListener('connect', connectListener);
                        _this.removeListener('error', errorListener);
                        _this.removeListener('disconnecting', disconnectingListener);
                        return _this;
                    })];
            });
        });
    };
    /**
     * Disconnect the current socket connection.
     * @param timeout How long to wait before forcefully disconnecting.
     */
    ElkSocketConnection.prototype.disconnect = function (timeout) {
        if (timeout === void 0) { timeout = this.options.connectTimeout; }
        return __awaiter(this, void 0, void 0, function () {
            var closeListener, socket;
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, withTimeout(timeout, new Promise(function (resolve) {
                        if (!_this._socket) {
                            // Already disconnected, just resolve.
                            return resolve(_this);
                        }
                        socket = _this._socket;
                        if (_this.state === ElkConnectionState$1.Connecting) {
                            // If we're in the process of connecting, emit a
                            // `disconnecting` event that will cause the connect
                            // promise to be rejected.
                            _this.emit('disconnecting');
                            return resolve(_this);
                        }
                        closeListener = function () { return resolve(); };
                        socket.on('close', closeListener);
                        socket.end();
                    }))
                        .catch(function () {
                        socket.destroy();
                    })
                        .then(function () {
                        if (closeListener) {
                            socket.removeListener('close', closeListener);
                        }
                        return _this;
                    })];
            });
        });
    };
    /**
     * Sends data to the Elk M1. Typically this is an Elk Message packet
     * (but can also be arbitrary data, as is the case when authenticating).
     */
    ElkSocketConnection.prototype.write = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        if (!_this._socket) {
                            return reject(new WriteError(_this.state, 'No socket available for writing.'));
                        }
                        if (!_this._socket.writable) {
                            return reject(new WriteError(_this.state, 'Socket is not writeable'));
                        }
                        _this._socket.write(data, 'ascii', function () { return resolve(); });
                    })];
            });
        });
    };
    return ElkSocketConnection;
}(EventEmitter));

/**
 * The control panel sends this when prompting for a username.
 */
var USERNAME_REQUEST = '\r\nUsername: ';
/**
 * The control panel sends this when prompting for a password.
 */
var PASSWORD_REQUEST = '\r\nPassword: ';
/**
 * The control panel sends this when logging in fails.
 */
var LOGIN_FAILURE = '\r\nUsername/Password not found.\r\n';
/**
 * The control panel sends this when logging in is susccessful
 */
var LOGIN_SUCCESSFUL = '\r\nElk-M1XEP: Login successful.\r\n';
/**
 * The default timeout for command responses when not specified.
 */
var DEFAULT_RESPONSE_TIMEOUT = 30 * 1000;
/**
 * The default connect timeout value when not specified.
 */
var DEFAULT_CONNECT_TIMEOUT = 60 * 1000;
var ElkClient = /** @class */ (function (_super) {
    __extends(ElkClient, _super);
    function ElkClient(options) {
        if (options === void 0) { options = { connection: {} }; }
        var _this = _super.call(this) || this;
        _this.options = options;
        _this._state = ElkClientState$1.Disconnected;
        _this._authenticated = false;
        _this.onConnectionConnected = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.emit('connected');
                // At this point we may need to authenticate.
                // The panel will send "\r\nUsername: " to request
                // the username. and that will cause the authentication
                // process to be triggered and that will eventually
                // lead to a "ready" or "error" being emitted, depending
                // on whether the authentication was successful.
                // But in the case that we DON'T need to authenticate,
                // we just immediately trigger the ready state. Otherwise
                // we'd have to wait for the panel to emit some data
                // to trigger that, and that could be up to 30 seconds
                // depending on the timing (an "XK" message is emitted
                // every 30 seconds).
                if (!this.options.username) {
                    this.onReady(false);
                }
                return [2 /*return*/];
            });
        }); };
        _this.onConnectionDisconnecting = function () {
            _this._state = ElkClientState$1.Disconnecting;
            _this.emit('disconnecting');
        };
        _this.onConnectionDisconnected = function () {
            _this._state = ElkClientState$1.Disconnected;
            _this._authenticated = false;
            _this.emit('disconnected');
        };
        _this.onConnectionError = function (error) {
            _this.emit('error', error);
        };
        _this.onConnectionData = function (data) { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = data;
                        switch (_a) {
                            case USERNAME_REQUEST: return [3 /*break*/, 1];
                            case PASSWORD_REQUEST: return [3 /*break*/, 4];
                            case LOGIN_FAILURE: return [3 /*break*/, 7];
                            case LOGIN_SUCCESSFUL: return [3 /*break*/, 9];
                        }
                        return [3 /*break*/, 10];
                    case 1:
                        if (!!this.options.username) return [3 /*break*/, 3];
                        this.emit('error', new AuthenticationFailedError(AuthenticationFailedReason.MissingUsername, 'Username was requested but none was provided.'));
                        return [4 /*yield*/, this.disconnect()];
                    case 2:
                        _b.sent();
                        return [2 /*return*/];
                    case 3:
                        this._state = ElkClientState$1.Authenticating;
                        this.emit('authenticating');
                        this._connection.write(this.options.username + '\r\n').catch(function () { return undefined; });
                        return [3 /*break*/, 11];
                    case 4:
                        if (!!this.options.password) return [3 /*break*/, 6];
                        this.emit('error', new AuthenticationFailedError(AuthenticationFailedReason.MissingPassword, 'Password was requested but none was provided.'));
                        return [4 /*yield*/, this.disconnect()];
                    case 5:
                        _b.sent();
                        return [2 /*return*/];
                    case 6:
                        this._connection.write(this.options.password + '\r\n').catch(function () { return undefined; });
                        return [3 /*break*/, 11];
                    case 7:
                        this.emit('error', new AuthenticationFailedError(AuthenticationFailedReason.InvalidCredentials, 'Login failed, invalid username or password.'));
                        return [4 /*yield*/, this.disconnect()];
                    case 8:
                        _b.sent();
                        return [2 /*return*/];
                    case 9:
                        {
                            this.onReady(true);
                            return [3 /*break*/, 11];
                        }
                    case 10:
                        {
                            // We need to ignore any other responses while we're authenticating
                            // because the username and password will be echoed back
                            if (this._state !== ElkClientState$1.Authenticating) {
                                if (!this.isReady && this.isConnected) {
                                    // If we're getting data and connected, but not "ready",
                                    // we need to switch to a ready state. This could happen if
                                    // a username was provided but not requested by the control
                                    // panel.
                                    this.onReady();
                                }
                                // The M1 doesn't always send a single packet, so we need to check
                                // for multiple packets at once.
                                data
                                    .split(/\r\n|\r|\n/)
                                    .filter(function (packet) { return !!packet; })
                                    .forEach(function (packet) {
                                    if (packet === 'OK') {
                                        _this.emit('ok');
                                    }
                                    else {
                                        _this.emit('message', parse(packet + '\r\n'));
                                    }
                                });
                            }
                        }
                        _b.label = 11;
                    case 11: return [2 /*return*/];
                }
            });
        }); };
        _this._connection = new ElkSocketConnection(options.connection);
        _this._connection.on('connected', _this.onConnectionConnected);
        _this._connection.on('disconnecting', _this.onConnectionDisconnecting);
        _this._connection.on('disconnected', _this.onConnectionDisconnected);
        _this._connection.on('data', _this.onConnectionData);
        _this._connection.on('error', _this.onConnectionError);
        return _this;
    }
    Object.defineProperty(ElkClient.prototype, "connection", {
        /**
         * Gets the underlying ElkConnection.
         */
        get: function () {
            return this._connection;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElkClient.prototype, "defaultTimeout", {
        /**
         * The default number of milliseconds to wait for a command
         * response before returning a timeout error.
         */
        get: function () {
            return this.options.responseTimeout || DEFAULT_RESPONSE_TIMEOUT;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElkClient.prototype, "authenticated", {
        /**
         * True if the currently authenticated; otherwise, false.
         */
        get: function () {
            return this._authenticated;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElkClient.prototype, "state", {
        /**
         * The client's current state.
         */
        get: function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElkClient.prototype, "isReady", {
        /**
         * True if the client is in a ready state and is able
         * to communicate with the Elk M1.
         */
        get: function () {
            return this._state === ElkClientState$1.Ready;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElkClient.prototype, "isConnected", {
        /**
         * True if the underlying connection is connected.
         */
        get: function () {
            return this._connection.state === ElkConnectionState$1.Connected;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Attempts to connect (and authenticate, if needed) to the Elk M1.
     * Resolves when the client become ready, or rejects if there is an
     * error or if a ready state cannot be reached within the timeout
     * period.
     * @param timeoutMs How long to wait for the client to become
     *   ready.
     */
    ElkClient.prototype.connect = function (timeoutMs) {
        if (timeoutMs === void 0) { timeoutMs = this.options.connectTimeout || DEFAULT_CONNECT_TIMEOUT; }
        return __awaiter(this, void 0, void 0, function () {
            var errorListener, readyListener;
            var _this = this;
            return __generator(this, function (_a) {
                if (this.state === ElkClientState$1.Ready) {
                    return [2 /*return*/, Promise.resolve(this)];
                }
                return [2 /*return*/, withTimeout(timeoutMs, new Promise(function (resolve, reject) {
                        readyListener = function () { return resolve(); };
                        errorListener = function (error) { return reject(error); };
                        _this.on('ready', readyListener);
                        _this.on('error', errorListener);
                        // We can safely ignore rejected promises from these
                        // connect calls because they will also trigger
                        // error callbacks, which we will be listening for.
                        if (_this._connection.state === ElkConnectionState$1.Disconnecting) {
                            // If we're in the process of closing the connection, wait for it
                            // to close then try to connect.
                            _this._connection
                                .disconnect()
                                .then(function () { return _this._connection.connect(); })
                                .catch(function () { return undefined; });
                        }
                        else {
                            _this._connection.connect().catch(function () { return undefined; });
                        }
                    }))
                        .catch(function (error) {
                        _this.removeListener('ready', readyListener);
                        _this.removeListener('error', errorListener);
                        throw error;
                    })
                        .then(function () {
                        _this.removeListener('ready', readyListener);
                        _this.removeListener('error', errorListener);
                        return _this;
                    })];
            });
        });
    };
    /**
     * Disconnects the current connection and resolves
     * when completed.
     */
    ElkClient.prototype.disconnect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._connection.disconnect()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sends a command to the Elk M1 control panel.
     */
    ElkClient.prototype.sendCommand = function (command, timeoutMs) {
        if (timeoutMs === void 0) { timeoutMs = this.defaultTimeout; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, withTimeout(timeoutMs, this._connection.write(command.raw).then(function () { return undefined; }))];
            });
        });
    };
    ElkClient.prototype.onReady = function (authenticated) {
        if (authenticated === void 0) { authenticated = false; }
        this._state = ElkClientState$1.Ready;
        if (authenticated) {
            this._authenticated = true;
            this.emit('authenticated');
        }
        this.emit('ready');
    };
    return ElkClient;
}(ElkClientCommands));

var ElkDeviceType;
(function (ElkDeviceType) {
    /**
     * M1XEP devices
     */
    ElkDeviceType[ElkDeviceType["M1XEP"] = 1] = "M1XEP";
    /**
     * C1M1 communicators
     */
    ElkDeviceType[ElkDeviceType["C1M1"] = 2] = "C1M1";
})(ElkDeviceType || (ElkDeviceType = {}));
var ElkDeviceType$1 = ElkDeviceType;

/**
 * Extracts a MAC address from 6 bytes of a data buffer
 * @param buffer The data buffer
 * @param startIndex The index within the buffer where the MAC address is specified.
 * @param [separator=":"] The separator character to use between octets
 */
function extractMacAddress(buffer, startIndex, separator) {
    if (separator === void 0) { separator = ':'; }
    return Array.from(buffer.slice(startIndex, startIndex + 6))
        .map(function (value) { return value.toString(16).padStart(2, '0'); })
        .join(separator);
}
/**
 * Extracts an IP address from 4 bytes of a data buffer
 * @param buffer The data buffer
 * @param startIndex The index within the buffer where the IP address is specified.
 */
function extractIpAddress(buffer, startIndex) {
    return Array.from(buffer.slice(startIndex, startIndex + 4))
        .map(function (value) { return value.toString(10); })
        .join('.');
}
/**
 * Extracts a port number from 2 bytes of a data buffer
 * @param buffer The data buffer
 * @param startIndex The index within the buffer where the port is specified.
 */
function extractPort(buffer, startIndex) {
    return buffer[startIndex] * 256 + buffer[startIndex + 1];
}
/**
 * Decodes an `ElkDevice` configuration from a UDP discovery response.
 * @param data The UDP response data.
 */
function decode(data) {
    // In both cases, the format of the response starts with:
    //
    //   `DDDDDMMMMMMIIIIPP`
    //
    // where:
    //   * `DDDDD` - A device type identifier (either "C1M1 " or "M1XEP"
    //   * `MMMMMM` - The MAC address
    //   * `IIII` - The IP address, where each byte is one octet
    //   * `PP` - The port to use to connect to the device
    //
    // The remaining bytes vary depending on the device type
    var identifier = data.slice(0, 5).toString();
    if (identifier === 'C1M1 ') {
        return {
            deviceType: ElkDeviceType$1.C1M1,
            macAddress: extractMacAddress(data, 5),
            ipAddress: extractIpAddress(data, 11),
            port: extractPort(data, 15),
            // For C1M1, the next 2 bytes represent the port to use
            // for secure connections.
            securePort: extractPort(data, 17),
        };
    }
    else if (identifier === 'M1XEP') {
        return {
            deviceType: ElkDeviceType$1.M1XEP,
            macAddress: extractMacAddress(data, 5),
            ipAddress: extractIpAddress(data, 11),
            port: extractPort(data, 15),
            // For M1XEP, there is a customizable 16-character
            // "name" that can be used to identify the device.
            name: data.toString('ascii', 17, 17 + 16).trim(),
        };
    }
    throw new Error('Unknown response recieved with ID: ' + identifier);
}

var DEFAULT_DISCOVERY_OPTIONS = {
    // This is what ElkRP2 uses, but I've found local broadcast
    // addresses work as well (i.e.: 192.168.1.255)
    broadcastAddress: '255.255.255.255',
    // Attempt to discover all devices by default.
    deviceTypes: undefined,
    // Wait 5 seconds for responses.
    timeout: 5000,
    // ElkRP2 uses 2362 exclusively. Not sure if other ports will work.
    port: 2362,
};

var C1M1_DISCOVERY_ID = Buffer.from('C1M1ID', 'ascii');
var M1XEP_DISCOVERY_ID = Buffer.from('XEPID', 'ascii');
/**
 * A client that can be used to discover Elk M1 devices on the
 * local network using UDP broadcasts.
 */
var ElkDiscoveryClient = /** @class */ (function (_super) {
    __extends(ElkDiscoveryClient, _super);
    function ElkDiscoveryClient(initialOptions) {
        if (initialOptions === void 0) { initialOptions = {}; }
        var _this = _super.call(this) || this;
        /**
         * Starts the discovery process, resolving when complete (after the timeout),
         * or rejecting if an error occured.
         */
        _this.start = function () { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var _a = _this.options, broadcastAddress = _a.broadcastAddress, deviceTypes = _a.deviceTypes, port = _a.port, timeout = _a.timeout;
                        var socket = createSocket$2({ type: 'udp4', reuseAddr: true });
                        var complete = false;
                        var devices = {};
                        socket.on('message', function (msg, rinfo) {
                            // Since the discovery requests are broadcast, we actually receive them as well,
                            // so ignore those.
                            if (msg.equals(C1M1_DISCOVERY_ID) || msg.equals(M1XEP_DISCOVERY_ID)) {
                                return;
                            }
                            try {
                                var device = decode(msg);
                                devices[device.macAddress] = device;
                                // devices.push(device);
                                _this.emit('found', device);
                            }
                            catch (err) {
                                // Ignore unknown messages
                                _this.emit('unknownMessage', msg);
                            }
                        });
                        socket.on('close', function () {
                            if (!complete) {
                                complete = true;
                                _this.emit('complete', devices);
                                resolve(Object.values(devices));
                            }
                        });
                        socket.on('error', function (error) {
                            if (!complete) {
                                complete = true;
                                reject(error);
                            }
                            try {
                                socket.close();
                            }
                            catch (err) {
                                // Ignore this, socket was already closed.
                            }
                        });
                        socket.bind(port, function () {
                            socket.setBroadcast(true);
                            if (!deviceTypes || deviceTypes.includes(ElkDeviceType$1.C1M1)) {
                                socket.send(C1M1_DISCOVERY_ID, 0, C1M1_DISCOVERY_ID.length, port, broadcastAddress);
                            }
                            if (!deviceTypes || deviceTypes.includes(ElkDeviceType$1.M1XEP)) {
                                socket.send(M1XEP_DISCOVERY_ID, 0, M1XEP_DISCOVERY_ID.length, port, broadcastAddress);
                            }
                            setTimeout(function () {
                                socket.close();
                            }, timeout);
                        });
                    })];
            });
        }); };
        _this.options = __assign(__assign({}, DEFAULT_DISCOVERY_OPTIONS), initialOptions);
        return _this;
    }
    return ElkDiscoveryClient;
}(EventEmitter));

export { AuthenticationFailedError, ConnectCancelledError, ElkClient, ElkClientState$1 as ElkClientState, ElkConnectionState$1 as ElkConnectionState, ElkDeviceType$1 as ElkDeviceType, ElkDiscoveryClient, ElkSocketConnection, NotConnectableError, WriteError };
//# sourceMappingURL=index.es5.js.map
