/// <reference types="node" />
import { AlarmByZoneReport, ArmingLevel, ArmingStatusReport, AudioDataReply, ControlOutputStatusReport, CounterValueReply, CustomValue, CustomValueReply, DayOfWeek, DisplayTextClearOption, ElkCommand, ElkResponse, FunctionKey, InsteonLightingDeviceProgrammed, InsteonLightingDeviceStatusReply, KeypadAreaAssignments, KeypadKeyChange, LightingDeviceDataReply, LogWriteType, MonthOfYear, Omnistat2Reply, PlcDeviceStatusReply, PlcFunctionCode, RealTimeClockDataReply, SystemLogDataUpdate, SystemTroubleStatusReply, TemperatureData, TemperatureDeviceType, TemperatureReply, TextDescriptionReply, TextDescriptionType, ThermostatData, ThermostatMode, ThermostatSetType, UserCode, UserCodeAreasReply, UserCodeChangeReply, UserCodeChangeType, VersionNumberReply, ZoneBypassReply, ZoneDefinitionData, ZonePartitionReport, ZoneStatusReport, ZoneVoltageData } from 'elk-message';
import { EventEmitter } from 'events';
import ElkClientEvents from './ElkClientEvents';
/**
 * An abstract client implementation of sending/receiving specific
 * messages from the Elk M1.
 *
 * This is just a way to declutter the client and separate out the
 * specific command implementations.
 */
declare abstract class ElkClientCommands extends EventEmitter implements ElkClientEvents {
    abstract sendCommand(command: ElkCommand, timeout?: number): Promise<void>;
    abstract readonly defaultTimeout: number;
    /**
     * Waits for a response that matches the predicate provided and resolves when it
     * is found, or rejects if it is not found within the timeframe.
     */
    waitForResponse(predicate: (response: ElkResponse) => boolean, timeoutMs?: number): Promise<ElkResponse>;
    /**
     * Waits for an "OK" response and resolves when it is found, or rejects if it is not found within the
     * timeout time.
     */
    waitForOk(timeoutMs?: number): Promise<ElkResponse>;
    /**
     * Sends a command and waits for a {@link ElkResponse}
     * @param command The command to send
     * @param predicate A predicate function that is called for *every* response that
     *   is recevied and should return true when a response matches an expected
     *   response to the command that was sent.
     * @param timeout How long to wait for the response before rejecting.
     */
    sendCommandForResponse(command: ElkCommand, predicate: (response: ElkResponse) => boolean, timeoutMs?: number): Promise<ElkResponse>;
    /**
     * Helper method for sending a command and waiting for an "OK" response.
     */
    sendCommandForOk(command: ElkCommand, timeoutMs?: number): Promise<ElkResponse>;
    /**
     * Helper method for sending a command and waiting for a response that matches the
     * type of response class given.
     *
     * Useful for commands that only need to check the type of response message, and not
     * any of it's underlying data.
     */
    sendCommandForResponseType<T extends ElkResponse>(command: ElkCommand, ResponseClass: Function): Promise<T>;
    arm(areaNumber: number, armingLevel: ArmingLevel, userCode: string): Promise<void>;
    disarm(areaNumber: number, userCode: string): Promise<void>;
    getArmingStatus(): Promise<ArmingStatusReport>;
    getAlarmsByZone(): Promise<AlarmByZoneReport>;
    getAudioData(zoneNumber: number): Promise<AudioDataReply>;
    setControlOutputOff(outputNUmber: number): Promise<void>;
    setControlOutputOn(outputNUmber: number): Promise<void>;
    toggleControlOutput(outputNumber: number): Promise<void>;
    getControlOutputStatus(): Promise<ControlOutputStatusReport>;
    getCustomValue(valueNumber: number): Promise<CustomValueReply>;
    getCustomValues(): Promise<CustomValueReply>;
    setCustomValue(valueNumber: number, value: CustomValue): Promise<CustomValueReply>;
    changeUserCode(userNumber: number, masterOrCurrentUserCode: string | UserCode, newUserCode: string | UserCode, areaNumbers?: number[] | undefined, changeType?: UserCodeChangeType): Promise<UserCodeChangeReply>;
    getCounterValue(counterNumber: number): Promise<CounterValueReply>;
    setCounterValue(counterNumber: number, value: number): Promise<CounterValueReply>;
    displayTextOnScreen(areaNumber: number, firstLine?: string | null, secondLine?: string | null, clearOption?: DisplayTextClearOption, beep?: boolean, timeout?: number): Promise<void>;
    clearTextOnScreen(areaNumber: number, beep?: boolean): Promise<void>;
    getLightingDeviceStatus(lightingDeviceNumber: number): Promise<LightingDeviceDataReply>;
    getInsteonLightingDeviceStatus(startingDeviceNumber: number, deviceCount: number): Promise<InsteonLightingDeviceStatusReply>;
    setInsteaonLightingDevice(startingDeviceNumber: number, deviceIds: string[]): Promise<InsteonLightingDeviceProgrammed>;
    getKeypadAreaAssignments(): Promise<KeypadAreaAssignments>;
    getKeypadFunctionKeyStatus(keypadNumber: number): Promise<KeypadKeyChange>;
    pressKeypadFunctionKey(keypadNumber: number, functionKey?: FunctionKey): Promise<KeypadKeyChange>;
    getSystemLogData(logIndex: number): Promise<SystemLogDataUpdate>;
    writeSystemLogData(logType: LogWriteType, eventType: number, zoneNumber: number, areaNumber: number): Promise<ElkResponse>;
    getTemperatureData(): Promise<TemperatureData>;
    setPlcDevice(houseCode: string, unitCode: number, functionCode: PlcFunctionCode, extendedCode: number, onTime: number): Promise<void>;
    setPlcDeviceOff(houseCode: string, unitCode: number): Promise<void>;
    setPlcDeviceOn(houseCode: string, unitCode: number): Promise<void>;
    togglePlcDevice(houseCode: string, unitCode: number): Promise<void>;
    getPlcStatus(bank: number): Promise<PlcDeviceStatusReply>;
    getRealTimeClock(): Promise<RealTimeClockDataReply>;
    setRealTimeClock(year: number, month: MonthOfYear, day: number, dayOfWeek: DayOfWeek, hour: number, minutes: number, seconds: number): Promise<RealTimeClockDataReply>;
    getDescription(textType: TextDescriptionType, address: number): Promise<TextDescriptionReply>;
    getTroubleStatus(): Promise<SystemTroubleStatusReply>;
    getTemperature(deviceType: TemperatureDeviceType, deviceNumber: number): Promise<TemperatureReply>;
    speakWord(wordNumber: number): Promise<void>;
    speakPhrase(phraseNumber: number): Promise<void>;
    activateTask(taskNumber: number): Promise<void>;
    getThermostatData(thermostatNumber: number): Promise<ThermostatData>;
    setThermostat(thermostatNumber: number, value: number, element: ThermostatSetType): Promise<ThermostatData>;
    setThermostatCoolSetPoint(thermostatNumber: number, temperature: number): Promise<ThermostatData>;
    setThermostatHeatSetPoint(thermostatNumber: number, temperature: number): Promise<ThermostatData>;
    setThermostatFan(thermostatNumber: number, on: boolean): Promise<ThermostatData>;
    setThermostatMode(thermostatNumber: number, mode: ThermostatMode): Promise<ThermostatData>;
    setThermostatHold(thermostatNumber: number, on: boolean): Promise<ThermostatData>;
    getOmnistat2Data(onmistatData: string): Promise<Omnistat2Reply>;
    getVersionNumber(): Promise<VersionNumberReply>;
    getValidUserCodeAreas(userCode: string): Promise<UserCodeAreasReply>;
    toggleBypassForZone(pinCode: string, zoneNumber: number): Promise<ZoneBypassReply>;
    toggleBypassForArea(pinCode: string, areaNumber: number): Promise<ZoneBypassReply>;
    getZonePartitions(): Promise<ZonePartitionReport>;
    getZoneStatus(): Promise<ZoneStatusReport>;
    getZoneDefinitions(): Promise<ZoneDefinitionData>;
    triggerZone(zoneNumber: number): Promise<void>;
    getZoneVoltage(zoneNumber: number): Promise<ZoneVoltageData>;
}
export default ElkClientCommands;
