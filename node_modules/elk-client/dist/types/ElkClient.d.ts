import { ElkCommand } from 'elk-message';
import ElkConnection from './connection/ElkConnection';
import ElkClientCommands from './ElkClientCommands';
import ElkClientState from './ElkClientState';
import ElkClientOptions from './ElkClientOptions';
declare class ElkClient extends ElkClientCommands {
    readonly options: ElkClientOptions;
    private _connection;
    private _state;
    private _authenticated;
    constructor(options?: ElkClientOptions);
    /**
     * Gets the underlying ElkConnection.
     */
    get connection(): ElkConnection;
    /**
     * The default number of milliseconds to wait for a command
     * response before returning a timeout error.
     */
    get defaultTimeout(): number;
    /**
     * True if the currently authenticated; otherwise, false.
     */
    get authenticated(): boolean;
    /**
     * The client's current state.
     */
    get state(): ElkClientState;
    /**
     * True if the client is in a ready state and is able
     * to communicate with the Elk M1.
     */
    get isReady(): boolean;
    /**
     * True if the underlying connection is connected.
     */
    get isConnected(): boolean;
    /**
     * Attempts to connect (and authenticate, if needed) to the Elk M1.
     * Resolves when the client become ready, or rejects if there is an
     * error or if a ready state cannot be reached within the timeout
     * period.
     * @param timeoutMs How long to wait for the client to become
     *   ready.
     */
    connect(timeoutMs?: number): Promise<ElkClient>;
    /**
     * Disconnects the current connection and resolves
     * when completed.
     */
    disconnect(): Promise<void>;
    /**
     * Sends a command to the Elk M1 control panel.
     */
    sendCommand(command: ElkCommand, timeoutMs?: number): Promise<undefined>;
    private onReady;
    private onConnectionConnected;
    private onConnectionDisconnecting;
    private onConnectionDisconnected;
    private onConnectionError;
    private onConnectionData;
}
export default ElkClient;
